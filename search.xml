<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Pixel4-解锁BL+ROOT+开启Motion-Sense</title>
      <link href="/2021/07/04/Pixel4-%E8%A7%A3%E9%94%81BL+ROOT+%E5%BC%80%E5%90%AFMotion-Sense/"/>
      <url>/2021/07/04/Pixel4-%E8%A7%A3%E9%94%81BL+ROOT+%E5%BC%80%E5%90%AFMotion-Sense/</url>
      
        <content type="html"><![CDATA[<p>​    最近花1200入手了一台pixel4，到手后为了发现网络连接不断提示无法连接互联网，影响到部分程序的正常联网使用。提示无法连接网络的原因是由于Pixel默认使用google域名进行网络验证，而google由于众所周知的原因在国内无法顺利访问。其实这个问题用非ROOT的方法也可以解决。</p><h4 id="获取ROOT："><a href="#获取ROOT：" class="headerlink" title="获取ROOT："></a>获取ROOT：</h4><p>基本上我的操作步骤如第一篇文章所述，部分细节需要注意，不得不说，国外的论坛真的大多简单明了还不收费，国内很多都是一通抄袭,而且步驟非常不完整。本文其實大部分内容都是引用自其他内容,但是做了較爲完整的整合引用,以及細節説明.</p><ol><li><p>获取Boot Image镜像</p><p>如链接[3]，源文中未给出具体链接，这里一定要选择与手机一致的版本号，</p></li></ol><p>Settings &gt; About phone &gt; Build number.</p><p><img src="https://github.com/zkeenly/myblog/blob/master/source/images/2021-07-04-1.png" alt="1625390973678"></p><p>将文件解压，取出压缩包中的boot.img 文件，将文件拷贝到手机目录中（建议选择Download路径，不然后面找起来比较麻烦）</p><ol start="2"><li><p>Magisk Manager</p><p>面具的下载地址有很多了，如果能访问官网，我建议是直接从连接[4]中下载最新版本，安装完毕后选择install&gt; select and patch a file &gt; 选择boot.img文件，选择完毕之后，它将会给你一个magisk_patched.img 文件，记得把这个文件再拷贝回去电脑上留着。</p></li><li><p>打开OEM锁</p><p>去设置里将选择&gt;About phone. &gt;多次點擊Build number &gt; 返回上級頁面 ,選擇System &gt; Developer Options. &gt; 打開OEM unlocking</p></li><li><p>安裝ADB</p><p>ADB的安裝比較簡單,就是下載一個軟件包,免安裝,如[5].需要注意的是,一定要使用CMD打開命令行,不要使用powershell.</p></li><li><p>Unlock Bootloader</p><p>解鎖BL,需要關閉手機,然後按下電源按鍵以及音量減(注意是音量-).另外在此之前還需要安裝驅動.驱动程序文件如[6],安裝驅動方法如[7].</p><p>安装好驱动后,在手机打开USB调试模式</p><p>输入命令:</p><p>adb devices</p><p>可检查是否正常连接.</p><p>进入BL页面后,可以通过命令</p><p>fastboot devices</p><p>检查是否有正常连接.</p><p>进入BL页面之后,电脑连接手机,打开命令行输入</p><p>fastboot flashing unlock</p><p>即可解锁</p><p>解锁完毕之后,再将我们拷贝出来的magisk_patched.img 文件刷入手机</p><p>fastboot flash boot path/to/magisk_patched.img</p><p>其中path/to 为本地文件所在的路径.</p></li></ol><p>至此ROOT已经完毕，获取到ROOT之后，手机开机会有一个风险提示，忽略即可。</p><p>另外面具APP可能无法正常使用，需要重新安装。</p><h4 id="解锁Motion-Sense："><a href="#解锁Motion-Sense：" class="headerlink" title="解锁Motion Sense："></a>解锁Motion Sense：</h4><p>解锁Motion Sense需要安装EdXposed,如链接[8]，在Modules中搜索enableSoliOnPixel4,如[13],安装即可。</p><p>也可以通过命令行方式修改，如链接[11]，但是据说重启会失效？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell setprop pixel.oslo.allowed_override 1</span><br></pre></td></tr></table></figure><h4 id="修改本地网络检查方式："><a href="#修改本地网络检查方式：" class="headerlink" title="修改本地网络检查方式："></a>修改本地网络检查方式：</h4><p>参考链接[10],将网络检查的地址修改为google中国的地址</p><p>删除默认地址</p><p>adb shell settings delete global captive_portal_https_url<br>adb shell settings delete global captive_portal_http_url</p><p>改用新地址</p><p>adb shell settings put global captive_portal_http_url <a href="http://captive.v2ex.co/generate_204" target="_blank" rel="noopener">http://captive.v2ex.co/generate_204</a><br>adb shell settings put global captive_portal_https_url <a href="https://captive.v2ex.co/generate_204" target="_blank" rel="noopener">https://captive.v2ex.co/generate_204</a></p><p>ref:</p><p>[1]<a href="https://www.xda-developers.com/google-pixel-4-root-magisk/" target="_blank" rel="noopener">https://www.xda-developers.com/google-pixel-4-root-magisk/</a>  获取root</p><p>[2]<a href="https://blog.csdn.net/asdrt12589wto1/article/details/115965281" target="_blank" rel="noopener">https://blog.csdn.net/asdrt12589wto1/article/details/115965281</a> 网络受限</p><p>[3]<a href="https://developers.google.com/android/ota" target="_blank" rel="noopener">https://developers.google.com/android/ota</a> 镜像下载</p><p>[4]<a href="https://magiskmanager.co/apk/" target="_blank" rel="noopener">https://magiskmanager.co/apk/</a> 面具</p><p>[5]<a href="https://www.xda-developers.com/install-adb-windows-macos-linux/" target="_blank" rel="noopener">https://www.xda-developers.com/install-adb-windows-macos-linux/</a> 安裝ADB</p><p>[6]<a href="https://developer.android.com/studio/run/win-usb?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/studio/run/win-usb?hl=zh-cn</a> 驱动</p><p>[7]<a href="https://blog.csdn.net/qz2014728/article/details/101760398" target="_blank" rel="noopener">https://blog.csdn.net/qz2014728/article/details/101760398</a> 安裝驅動</p><p>[8]<a href="https://edxposed.com/edxposed-install" target="_blank" rel="noopener">https://edxposed.com/edxposed-install</a> 安装Edxposed </p><p>[9]<a href="https://www.didgeridoohan.com/magisk/ManagerIssues" target="_blank" rel="noopener">https://www.didgeridoohan.com/magisk/ManagerIssues</a> 面具问题</p><p>[10]<a href="https://blog.csdn.net/asdrt12589wto1/article/details/115965281" target="_blank" rel="noopener">https://blog.csdn.net/asdrt12589wto1/article/details/115965281</a> 网络校验修正</p><p>[11]<a href="https://forum.xda-developers.com/t/magisk-tasker-release-motion-sense-soli-oslo-mod.3993877/#post-80729593" target="_blank" rel="noopener">https://forum.xda-developers.com/t/magisk-tasker-release-motion-sense-soli-oslo-mod.3993877/#post-80729593</a> 命令行启用motion sense</p><p>[12]<a href="https://www.xda-developers.com/enable-pixel-4-motion-sense-gestures/" target="_blank" rel="noopener">https://www.xda-developers.com/enable-pixel-4-motion-sense-gestures/</a> 启用motion sense</p><p>[13]<a href="https://forum.xda-developers.com/t/success-enable-soli-on-china.3994917/" target="_blank" rel="noopener">https://forum.xda-developers.com/t/success-enable-soli-on-china.3994917/</a> enableSoliOnPixel4</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> pixel </tag>
            
            <tag> root </tag>
            
            <tag> motion sense </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python中self参数的解释</title>
      <link href="/2019/03/22/python%E4%B8%ADself%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2019/03/22/python%E4%B8%ADself%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>这篇文章中我们将会讨论self 变量在python 中的应用。很多初学者都对python 中self的使用方法表示困惑。如果你也是这样，那么你应该读一下这篇文章。</p><p>一个简单的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaturant</span><span class="params">(object)</span>:</span></span><br><span class="line">bankrupt = <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_branch</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.bankrupt:</span><br><span class="line">            print(<span class="string">"branch opened"</span>)</span><br></pre></td></tr></table></figure><p>首先我们从非专业的角度解释这段代码。首先我们创建一个类 Restaurant。然后我们生命它的一个属性 bankrupt 为 false。然后我们定义一个函数open_branch ，仅当 bankrupt 为 false 的时候触发打印功能，这意味着Restautant 还有钱。</p><p>创建一个 resturant：</p><p>现在，我们来创建一个Restaurant类的对象，让我们创建一个resturant：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = Restaurant()</span><br></pre></td></tr></table></figure><p>现在 x 是一个Restaurant，并且具有bankrupt 属性以及一个open_branch 函数。现在我们可以通过以下代码访问这个bankrupt属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.bankrupt</span><br></pre></td></tr></table></figure><p>以下命令具有相同的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Restaurant().bankrupt</span><br></pre></td></tr></table></figure><p>现在你可以看到self 指的是绑定的变量或者对象。在第一个例子中，由于我们已经将Restaurant 类赋值到x，所以self 就是x，然而第二个例子中就是<code>Restaurant()</code> 。现在我们有另一个Restaurant y，self 将会自动访问y的bankrupt而不是x的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; x = Restaurant()</span><br><span class="line">&gt;&gt; x.bankrupt</span><br><span class="line">&gt;&gt; x.open_branch()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">branch opened</span><br><span class="line"></span><br><span class="line">&gt;&gt; y = Restaurant()</span><br><span class="line">&gt;&gt; y.bankrupt = <span class="keyword">True</span></span><br><span class="line">&gt;&gt; y.bankrupt</span><br><span class="line">&gt;&gt; y.open_branch()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; x.bankrupt</span><br><span class="line">&gt;&gt; x.open_branch()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">branch opened</span><br></pre></td></tr></table></figure><p><strong>在上面的例子中，当修改了x.bankrupt 之后， x.open_branch()也无法正常打印。简单的说，self就是类自身，通过self.xxx可以引用当前方法所在类的属性和方法。而在使用某个方法的时候并不需要为self参数传递值。</strong></p><p>每一个类的第一个方法（包括init），总是一个引用当前类的实例。更通俗的说，这个参数总是被成为self。在init 方法中，self 指的是新创建的对象；在其他类的方法中，它代表实例的方法被调用。下面的例子有相同的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(object)</span>:</span></span><br><span class="line">    bankrupt = <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_branch</span><span class="params">(this)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> this.bankrupt:</span><br><span class="line">            print(<span class="string">"branch opened"</span>)</span><br></pre></td></tr></table></figure><p>然而 self 在python 中并不是一个保留关键字，仅仅是一个普遍共识。许多人说为什么我们必须要写self？为什么不能像java一样自动设置？一些人也提交了PEP（改进建议）并建议移除这个self的声明。然而 GuidoVan Rossum 写了一个<a href="http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html" target="_blank" rel="noopener">bolg</a>解释为什么不得不声明self。</p><p>引用：</p><p>[1] <a href="https://pythontips.com/2013/08/07/the-self-variable-in-python-explained/" target="_blank" rel="noopener">https://pythontips.com/2013/08/07/the-self-variable-in-python-explained/</a><br>[2] <a href="http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html" target="_blank" rel="noopener">http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[ACM/算法]算法硬币问题</title>
      <link href="/2019/03/09/ACM-%E7%AE%97%E6%B3%95-%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/09/ACM-%E7%AE%97%E6%B3%95-%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>动态规划问题之一，硬币问题。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设有 1 元，3 元，5 元的硬币若干（无限），现在需要凑出 11 元，问如何组合才能使硬币的数量最少？</p><p>输入硬币种类数量为number，需要凑出的金钱为money</p><p>接下来number列，输入所有的硬币种类money_list[]</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们从凑出1元开始，依次递进，最终得到凑出11元的结果。</p><ol><li><p>假设res_list[i] 为凑出i元所需要的硬币数量</p></li><li><p>我们生成状态转移方程：</p><p>res_list[i] =min<sub>j=1…number</sub>[res_list[i-coin<sub>j</sub>] + 1)]，其中coin<sub>j</sub>为所有硬币种类硬币序列</p><p>即 当前凑出i的 最优解数量是凑出 i-coin<sub>j</sub> 的最优解 +1，且+1所代表的硬币是coin<sub>j</sub>。</p></li><li><p>res_list[0] 必定是0，res_list[1] = min<sub>j = 1… number</sub>[res_list[1-coin<sub>j</sub>] +1]</p></li><li><p>每次得到res_list[i]的值之后，都将当前的res_order[i-coin<sub>j</sub>]和coin<sub>j</sub>保存到res_order[i]中，作为硬币序列。</p></li></ol><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入硬币种类数量和需要凑的金钱</span></span><br><span class="line">number, money = input().split(<span class="string">' '</span>)</span><br><span class="line"><span class="comment"># 金钱种类列表，存放所有类型的硬币</span></span><br><span class="line">money_lists = []</span><br><span class="line"><span class="comment"># 输入所有硬币种类的面值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(int(number)):</span><br><span class="line">    money_lists.append(int(input()))</span><br><span class="line"></span><br><span class="line">res_list = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(int(money)+<span class="number">1</span>)]  <span class="comment"># 保存结果列表，每个数组都是该情况最小的种类数量</span></span><br><span class="line">res_order = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(int(money)+<span class="number">1</span>)]  <span class="comment"># 保存结果序列，其中每一个数组都保存了一个该情况的最小硬币序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(money)+<span class="number">1</span>):  <span class="comment"># 遍历所需要凑的金额</span></span><br><span class="line">    current_coin = <span class="number">-1</span></span><br><span class="line">    min_res = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> money_lists:  <span class="comment"># 遍历硬币面值</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j:  <span class="comment"># 确定不会超出界限，即当前需要的硬币总额不小于当前硬币面额</span></span><br><span class="line">            <span class="keyword">if</span> min_res == <span class="number">-1</span>:</span><br><span class="line">                min_res = res_list[i-j]+<span class="number">1</span></span><br><span class="line">                current_coin = j</span><br><span class="line">            <span class="keyword">elif</span> res_list[i-j]+<span class="number">1</span> &lt; min_res:</span><br><span class="line">                min_res = res_list[i-j]+<span class="number">1</span></span><br><span class="line">                current_coin = j</span><br><span class="line">    res_list[i] = min_res  <span class="comment"># 将最小的种类组合个数复制给当前res_lists</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> res_order[i-current_coin]:  <span class="comment"># 保存当前硬币序列到列表order。</span></span><br><span class="line">        <span class="comment"># print(res_order[i-current_coin])</span></span><br><span class="line">        <span class="comment"># print(i)</span></span><br><span class="line">        <span class="keyword">if</span> k != <span class="number">0</span>:</span><br><span class="line">            res_order[i].append(k)</span><br><span class="line">    <span class="keyword">if</span> current_coin != <span class="number">0</span>:</span><br><span class="line">        res_order[i].append(current_coin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(res_list)</span></span><br><span class="line">print(res_order)</span><br></pre></td></tr></table></figure><p>算法代码点击 <a href="https://github.com/zkeenly/articles/blob/master/CoinsProblems.py" target="_blank" rel="noopener">这里</a></p><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><p><a href="https://www.cnblogs.com/snowInPluto/p/5992846.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowInPluto/p/5992846.html</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[ACM/算法]01背包问题详解+扩展</title>
      <link href="/2019/03/08/ACM-%E7%AE%97%E6%B3%95-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3-%E6%89%A9%E5%B1%95/"/>
      <url>/2019/03/08/ACM-%E7%AE%97%E6%B3%95-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3-%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>01背包问题作为著名的动态规划问题之一，在算法学习中的意义不言而喻。</p><p>最近刷到一道题，在01背包问题中有稍微改变。</p><p><img src="https://www.zkeenly.com/images/2019-03-08-1.png" alt="BeiBaoQuestion"></p><p>题中不仅要求输出最大概率之和，还要求输出楼盘ID。</p><h3 id="动态规划问题"><a href="#动态规划问题" class="headerlink" title="动态规划问题"></a>动态规划问题</h3><p>例如输入序列为：</p><blockquote><p>5 10<br>2 0.2<br>3 0.3<br>4 0.44<br>5 0.55<br>6 0.6</p></blockquote><h4 id="贪心算法："><a href="#贪心算法：" class="headerlink" title="贪心算法："></a>贪心算法：</h4><p>第一种解法是贪心算法</p><ol><li>将所有楼盘序列计算出单位概率。</li><li>按照单位概率将序列排序。</li><li>依次从高概率遍历到低概率，从而得到局部最优解。</li></ol><p>算法代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greedy</span><span class="params">()</span>:</span></span><br><span class="line">    number, fund = input().split(<span class="string">' '</span>)</span><br><span class="line">    fund = int(fund)</span><br><span class="line">    array = []</span><br><span class="line">    max_prob = []</span><br><span class="line">    max_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(number)):  <span class="comment"># 输入锁定金额和概率</span></span><br><span class="line">        value, prob = input().split(<span class="string">' '</span>)</span><br><span class="line">        current_id = i+<span class="number">1</span></span><br><span class="line">        array.append([current_id, int(value), float(prob), float(prob)/float(value)])</span><br><span class="line">    print(array)</span><br><span class="line">    <span class="comment"># 第四位排序</span></span><br><span class="line">    array.sort(key=take_four, reverse=<span class="keyword">True</span>)</span><br><span class="line">    print(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:  <span class="comment"># 选中最佳可能的资金</span></span><br><span class="line">        max_value += i[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> max_value &lt; fund:</span><br><span class="line">            max_prob.append([i[<span class="number">0</span>], i[<span class="number">2</span>]])</span><br><span class="line">    print(<span class="string">'max_prob:'</span>, max_prob)</span><br><span class="line">    max_prob_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> max_prob:</span><br><span class="line">        max_prob_value = i[<span class="number">1</span>] + max_prob_value</span><br><span class="line">    print(max_prob_value, [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> max_prob])</span><br></pre></td></tr></table></figure><p>我们可以得到结果</p><p><code>0.99 [4, 3]</code></p><p>显然这不是我们想要的结果，因为最优解应该为1，2，4 = 1.05才对。</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="寻找最大概率值"><a href="#寻找最大概率值" class="headerlink" title="寻找最大概率值"></a>寻找最大概率值</h5><p>使用动态规划的方法解决该问题需要对问题建立转移方程：</p><ol><li><p>输入楼盘数量为number，总资金为fund</p></li><li><p>输入楼盘的数据raw_data.</p></li><li><p>定义子问题P(i, v)为在前i个楼盘中挑选总价值不超过v的楼盘，并且每个楼盘只能选择一次，使得最终抽中的总概率最大。我们此时的最优解记作max_prob(i, w)，其中1&lt;=i&lt;=number,1&lt;=w&lt;=fund。</p></li><li><p>当我们考虑第i个楼盘的时候：</p><p>如果不选择，则总资金容量不变，改为问题P(i-1, w)</p><p>如果选择这个楼盘，则总资金剩余容量变小，改问题为P(i-1, w-wi)</p></li><li><p>最优解的问题就是比较3中两个方案哪一个是最佳的：</p><p>max_prob(i,w) = max{max_prob(i-1,w),max_prob(i-1,w-wi)+valuei}</p></li></ol><p>例如输入序列为：</p><blockquote><p>5 10<br>2 0.2<br>3 0.3<br>4 0.44<br>5 0.55<br>6 0.6</p></blockquote><blockquote><p>假设我们一共有10W金钱，楼盘价值分别为2，3，4，5，6。楼盘概率分别为0.2，0.3，0.44，0.55，0.6。</p></blockquote><p>那么我们通过转移方程可以推算出以下表格max_prob：</p><p><img src="https://www.zkeenly.com/images/2019-03-08-2.png" alt="1552028354656"></p><p>推算过程:</p><ol><li><p>建立一个表格，大小为number×fund。</p></li><li><p>逐层遍历，按列遍历。</p><ol><li><p>当资金为1的时候，没有任何房产可以购买。</p></li><li><p>当资金为2的时候，可以购买房产1。</p></li><li><p>当资金为3的时候，可以购买房产1，但是当遍历到（2，3）的时候，对比</p><p>max{max_prob(i-1,w),max_prob(i-1,w-wi)+valuei}</p><p>其中max_prob(i-1,w) 代表i-1行w列。</p><p>其中max_prob(i-1,w)为0.2，max_prob(i-1,w-wi)+valuei 为0.2-0.2 + 0.3 = 0.3</p></li><li><p>经过逐次的遍历，得到最终整个矩阵数据。</p></li></ol></li></ol><p>算法代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dynasty</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ----------------输入数据----------------------</span></span><br><span class="line">    number, fund = input().split(<span class="string">' '</span>)</span><br><span class="line">    fund = int(fund)</span><br><span class="line">    number = int(number)</span><br><span class="line">    max_prob = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(fund+<span class="number">1</span>)] <span class="keyword">for</span> row <span class="keyword">in</span> range(number+<span class="number">1</span>)]</span><br><span class="line">    raw_data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(number)):  <span class="comment"># 输入锁定金额和概率</span></span><br><span class="line">        value, prob = input().split(<span class="string">' '</span>)</span><br><span class="line">        current_id = i+<span class="number">1</span></span><br><span class="line">        raw_data.append([current_id, int(value), float(prob), float(prob)/float(value)])</span><br><span class="line">    <span class="comment"># ---------------计算概率分布矩阵-------------------</span></span><br><span class="line">    all_max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number+<span class="number">1</span>):  <span class="comment"># 遍历所有的房价,number为房产个数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, fund+<span class="number">1</span>):  <span class="comment"># 遍历所有总金额,</span></span><br><span class="line">            <span class="comment"># print(i, j, raw_data[i-1][1])</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; raw_data[i<span class="number">-1</span>][<span class="number">1</span>]:  <span class="comment"># 假定的总金额小于当前房产的价格</span></span><br><span class="line">                max_prob[i][j] = max_prob[i<span class="number">-1</span>][j]  <span class="comment"># 概率等于之前的</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_prob[i][j] = max(max_prob[i<span class="number">-1</span>][j], (max_prob[i<span class="number">-1</span>][j-raw_data[i<span class="number">-1</span>][<span class="number">1</span>]] + raw_data[i<span class="number">-1</span>][<span class="number">2</span>]))</span><br><span class="line">                <span class="keyword">if</span> max_prob[i][j] &gt; all_max:  <span class="comment"># 记录概率最大值</span></span><br><span class="line">                    all_max = max_prob[i][j]</span><br><span class="line">   </span><br><span class="line"><span class="comment"># ----------------打印概率分布矩阵---------------</span></span><br><span class="line">    print(<span class="string">'概率分布矩阵:\n'</span>, max_prob)</span><br><span class="line">    print(<span class="string">'all_max_prob:'</span>, all_max)</span><br></pre></td></tr></table></figure><h5 id="计算楼盘的序列"><a href="#计算楼盘的序列" class="headerlink" title="计算楼盘的序列"></a>计算楼盘的序列</h5><ol><li><p>定义指针（i,j）倒序遍历表格</p></li><li><p>从末尾开始遍历,寻找按顺序排列第一次出现<code>all_max</code>节点,将<code>all_max</code>修改为<code>all_max-raw_data[i][prob]</code></p></li><li><p>当找到第一个星号1.05后移动指针位置到（i-1,j-1）,检测当前值是否为第一次出现的<code>all_max</code>,如果是，标记为星，并重复2步骤，直到遍历到（0，0）</p></li><li><p>输出所有标记星所在的行即为楼盘序列。</p><p><img src="https://www.zkeenly.com/images/2019-03-08-3.png" alt="1552030438642"></p></li></ol><p>算法代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ----------------从表中推出楼盘列表--------------</span></span><br><span class="line">id_list = []</span><br><span class="line"><span class="comment"># id_list.append(max_id)</span></span><br><span class="line"><span class="comment"># 反向查找关键节点</span></span><br><span class="line">j = fund  <span class="comment"># 定义列位置</span></span><br><span class="line">i = number  <span class="comment"># 定义行位置</span></span><br><span class="line"><span class="keyword">while</span> i != <span class="number">0</span> <span class="keyword">and</span> j != <span class="number">0</span>:  <span class="comment"># 从max_prob表右下位置开始，逆序遍历</span></span><br><span class="line">    <span class="comment"># print('all_max:', all_max)</span></span><br><span class="line">    print(<span class="string">'当前遍历的节点i,j,prob:'</span>, i, j, max_prob[i][j])</span><br><span class="line">    <span class="comment"># print('value:', int(max_prob[i][j]))</span></span><br><span class="line">    <span class="comment"># print('value_(i,j-1):', int(max_prob[i][j-1]))</span></span><br><span class="line">    <span class="comment"># 如果同行上一列的的概率值仍然为最大，则切换到上一列</span></span><br><span class="line">    <span class="keyword">if</span> max_prob[i][j<span class="number">-1</span>] == all_max:</span><br><span class="line">        <span class="comment"># print('j = j-1')</span></span><br><span class="line">        j = j<span class="number">-1</span></span><br><span class="line">    <span class="comment"># 如果同列上一行的的概率值仍然为最大，则切换到上一行</span></span><br><span class="line">    <span class="keyword">elif</span> max_prob[i - <span class="number">1</span>][j] == all_max:</span><br><span class="line">        <span class="comment"># print('i = i-1')</span></span><br><span class="line">        i = i<span class="number">-1</span></span><br><span class="line">    <span class="comment"># 处于拐点，可能是一个关键点。</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># print('test', int(max_prob[i][j]), int(all_max - raw_data[i-1][2]))</span></span><br><span class="line">        <span class="comment"># 如果当前概率等于最大的概率，则是关键点</span></span><br><span class="line">        <span class="keyword">if</span> max_prob[i][j] == all_max:</span><br><span class="line">            id_list.append(raw_data[i<span class="number">-1</span>][<span class="number">0</span>])  <span class="comment"># 保存当前楼盘的id</span></span><br><span class="line">            all_max = all_max - raw_data[i<span class="number">-1</span>][<span class="number">2</span>]  <span class="comment"># 转换当前最大概率，寻找下一个关键节点</span></span><br><span class="line">            print(<span class="string">'----当前楼盘是关键点之一：'</span>, i, <span class="string">'下一个节点prob为：'</span>, all_max)</span><br><span class="line">        i = i<span class="number">-1</span></span><br><span class="line">        j = j<span class="number">-1</span></span><br><span class="line">print(id_list)</span><br></pre></td></tr></table></figure><p>算法源码点击 <a href="https://github.com/zkeenly/articles/blob/master/KnapsackProblem.py" target="_blank" rel="noopener">这里</a></p><p>引用：</p><p><a href="https://blog.csdn.net/huanghaocs/article/details/77920358" target="_blank" rel="noopener">https://blog.csdn.net/huanghaocs/article/details/77920358</a></p><p><a href="https://zhuanlan.zhihu.com/p/30959069" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30959069</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论如何玩好QQ游戏-打手掌</title>
      <link href="/2019/02/24/%E8%AE%BA%E5%A6%82%E4%BD%95%E7%8E%A9%E5%A5%BDQQ%E6%B8%B8%E6%88%8F-%E6%89%93%E6%89%8B%E6%8E%8C/"/>
      <url>/2019/02/24/%E8%AE%BA%E5%A6%82%E4%BD%95%E7%8E%A9%E5%A5%BDQQ%E6%B8%B8%E6%88%8F-%E6%89%93%E6%89%8B%E6%8E%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zkeenly.com/images/2019-02-24-1.jpg" width="50%"></p><p>说到QQ游戏，给人的感觉像是回到了N年前一样,现在连小学生都不会玩了吧。</p><p>有一天发现QQ游戏有一个栏目-小比赛，使用小比赛中赢得的金豆可以兑换腾讯服务以及腾讯视频VIP，于是就选择了游戏“打手掌”试一试，玩了几局之后发现一个很容易获胜的规律分享给大家。</p><p><img src="https://zkeenly.com/images/2019-02-24-3.jpg" width="50%"></p><h4 id="当对方打你的时候如何闪避"><a href="#当对方打你的时候如何闪避" class="headerlink" title="当对方打你的时候如何闪避"></a>当对方打你的时候如何闪避</h4><p><img src="https://zkeenly.com/images/2019-02-24-7.gif" alt=""></p><p>一个小技巧就是手持续按着“闪避”按钮，一旦看到对方伸手来打，就立即松开按钮。这样做相比较看到了再去点击闪避要更容易躲过打击。</p><h4 id="如何高效的打中对方"><a href="#如何高效的打中对方" class="headerlink" title="如何高效的打中对方"></a>如何高效的打中对方</h4><p><img src="https://zkeenly.com/images/2019-02-24-5.gif" alt=""></p><p>当开始打击对方的时候：</p><ol><li>将右手指按在攻击按键上不要松开（注意手要稳一些，不要在按键上滑动，否则容易失去触点）。</li><li>持续点击假动作并观察对方动态。</li><li>一旦发现对方有收回迹象，立即松开攻击按键，手掌会迅速打击过去，几乎90%的概率可以打中。</li></ol><h4 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h4><p><img src="https://zkeenly.com/images/2019-02-24-6.jpg" width="50%"></p><p>打手掌一次可以收益180个金豆，一般的按照以上方法可以有100%的胜率，平局每一次（三局）大概需要2分钟。每天收益上限为2000金豆，大概就是30分钟以内可以达到上限收益。 <strong>持续5天即可兑换超级QQ会员一个月/腾讯视频VIP一个月/腾讯黄钻两个月</strong> （腾讯视频VIP现在每个月只能兑换一次/7天，2400金豆，而且每天一个上午就兑换完了，不知道还有没有9000金豆/一个月的兑换方法）。</p><p>当然游戏还是需要放松时娱乐一下就好。如果把它当成一件任务来完成也是蛮累的。</p><p>最后，不知道这个玩法算不算bug，说不定哪一天就被封了呢？有缘看到的网友就不要转载传播啦233（并且大家都知道后这个游戏也就不是那么容易获胜了）。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Latex论文写作</title>
      <link href="/2019/02/15/Latex%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"/>
      <url>/2019/02/15/Latex%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="推荐Latex书写工具"><a href="#推荐Latex书写工具" class="headerlink" title="推荐Latex书写工具"></a>推荐Latex书写工具</h3><blockquote><p>画图工具：<a href="https://www.draw.io/" target="_blank" rel="noopener">https://www.draw.io/</a></p><p>画表格工具：<a href="https://tablesgenerator.com/" target="_blank" rel="noopener">https://tablesgenerator.com/</a></p><p>在线写文档工具：<a href="https://www.overleaf.com" target="_blank" rel="noopener">https://www.overleaf.com</a></p></blockquote><h3 id="将数学公式转换为Latex"><a href="#将数学公式转换为Latex" class="headerlink" title="将数学公式转换为Latex"></a>将数学公式转换为Latex</h3><blockquote><ol><li><p>使用MathType 编辑数学公式</p><p><img src="https://www.zkeenly.com/images/2019-02-15-1.png" alt="1550221140686"></p></li><li><p>选项-剪切和复制选项</p><p><img src="https://www.zkeenly.com/images/2019-02-15-2.png" alt="1550221635453"></p></li><li><p>选择转换为latex</p><p><img src="https://www.zkeenly.com/images/2019-02-15-3.png" alt="1550221725345"></p></li><li><p>复制到notepad中即可看到latex格式的公式</p><p><code>\[E{\rm{ = mc}}\]</code></p></li></ol></blockquote><p>表格全文居中</p><p>图像排列</p><p>文献引用</p><p>整体流程</p><p>引用文献的article 和// </p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Tensorflow部分层初始化参数以及finetune</title>
      <link href="/2019/01/10/tensorflow%E9%83%A8%E5%88%86%E5%B1%82%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8Afinetune/"/>
      <url>/2019/01/10/tensorflow%E9%83%A8%E5%88%86%E5%B1%82%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8Afinetune/</url>
      
        <content type="html"><![CDATA[<p>本文在 tensorflow+slim 中实现基于原始卷积网络扩展增加新的层，然后finetune新的网络层参数。</p><h3 id="1，锁定部分变量（网络层），只finetune另一部分变量-网络层"><a href="#1，锁定部分变量（网络层），只finetune另一部分变量-网络层" class="headerlink" title="1，锁定部分变量（网络层），只finetune另一部分变量(网络层)"></a>1，锁定部分变量（网络层），只finetune另一部分变量(网络层)</h3><p>首先重置默认图,防止出现意外错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.reset_default_graph()  <span class="comment"># 重置默认图。</span></span><br></pre></td></tr></table></figure><p>定义网络操作pipeline,其中network为使用slim-api定义的一些列卷积操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in_image = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="number">4</span>])</span><br><span class="line">gt_image = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="number">3</span>])</span><br><span class="line">out_image = network(in_image)  <span class="comment"># 定义pipeline</span></span><br><span class="line">G_loss = tf.reduce_mean(tf.abs(out_image - gt_image))  <span class="comment"># 定义损失函数</span></span><br><span class="line">lr = tf.placeholder(tf.float32)  <span class="comment"># 定义学习率</span></span><br></pre></td></tr></table></figure><p>获取所有的网络参数(即定义网络层的scope=””)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_vars = tf.trainable_variables()  <span class="comment"># 获取所有的变量</span></span><br></pre></td></tr></table></figure><p>分别获取需要保持不变的变量和需要finetune的变量,scope中包含<code>g_add</code>的为附加finetune层.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_vars = [var <span class="keyword">for</span> var <span class="keyword">in</span> t_vars <span class="keyword">if</span> <span class="string">'g_add'</span> <span class="keyword">in</span> var.name]  <span class="comment"># 附加的finetune网络层</span></span><br><span class="line">var_list = [var <span class="keyword">for</span> var <span class="keyword">in</span> t_vars <span class="keyword">if</span> <span class="string">'g_conv'</span> <span class="keyword">in</span> var.name]  <span class="comment"># 不需要改变的网络层</span></span><br></pre></td></tr></table></figure><p>生成train_op,使用<code>var_list=g_vars</code> 设置仅需要finetune的部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G_opt = tf.train.AdamOptimizer(learning_rate=lr).minimize(G_loss, var_list=g_vars)  <span class="comment"># 只训练g_vars部分</span></span><br></pre></td></tr></table></figure><p>以上,其他部分按照正常操作即可以只训练g_vars部分,而不改变vart_list部分</p><h3 id="2，加载部分默认网络层参数-而不改变其他网络层的参数"><a href="#2，加载部分默认网络层参数-而不改变其他网络层的参数" class="headerlink" title="2，加载部分默认网络层参数,而不改变其他网络层的参数"></a>2，加载部分默认网络层参数,而不改变其他网络层的参数</h3><p>首先定义variables_to_restore,其中<code>exclude=[&quot;g_add&quot;]</code> 为不需要恢复的变量,也可以使用<code>include=[&quot;g_conv&quot;]</code> 来定义仅需要恢复的变量.[12] [14]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variables_to_restore = slim.get_variables_to_restore(exclude=[<span class="string">"g_add"</span>])  <span class="comment"># 一定要双引号,否则仅exclude 'g_add'一个层.</span></span><br></pre></td></tr></table></figure><p>建立一个re_saver来从已有的模型中恢复g_conv系列参数到网络中.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re_saver = tf.train.Saver(variables_to_restore)  <span class="comment"># 建立一个saver 用来保存需要恢复的模型变量</span></span><br></pre></td></tr></table></figure></p><p>再建立一个saver,用来训练的时候保存整个模型的ckpt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saver = tf.train.Saver()  <span class="comment"># 建立一个模型，用来保存所有的模型变量</span></span><br></pre></td></tr></table></figure><p>将外置模型参数加载到将要训练的模型sess中,并且初始化其余未初始化的参数,训练以及保存模型.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    model_path = <span class="string">'./model.ckpt'</span>  <span class="comment"># 后缀名称仅需要写ckpt即可,后面的00001-00000不必添加</span></span><br><span class="line">    re_saver.restore(sess=sess, save_path=model_path)  <span class="comment"># 恢复模型的参数到新的模型</span></span><br><span class="line">    un_init = tf.variables_initializer(get_uninitialized_variables(sess))  <span class="comment"># 获取没有初始化(通过已有model加载)的变量 </span></span><br><span class="line">    sess.run(un_init)  <span class="comment"># 对没有初始化的变量进行初始化并训练.</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(lastepoch, <span class="number">4001</span>):</span><br><span class="line">    _, G_current, output = sess.run([G_opt, G_loss, out_image],</span><br><span class="line">                                        feed_dict=&#123;in_image: input_patch, gt_image: gt_patch, lr: learning_rate&#125;)  <span class="comment"># 执行训练</span></span><br><span class="line">    saver.save(sess, checkpoint_dir + <span class="string">'model.ckpt'</span>)  <span class="comment"># 使用saver.save保存训练模型</span></span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    网上查的资料大多大同小异,但是有一点都未曾提及,就是训练中保存变量的时候不应该用恢复网络参数所使用的saver来保存全部的参数.否则将只保存原始加载的那部分参数.而新finetune 的layer将无法保存.导致再测试的时候出现找不到某些层的bug</p><p><code>[TensorFlow: NotFoundError: Key not found in checkpoint]</code></p><p>引用：</p><p>[1] <a href="http://www.tensorfly.cn/tfdoc/how_tos/variables.html" target="_blank" rel="noopener">http://www.tensorfly.cn/tfdoc/how_tos/variables.html</a></p><p>[2] <a href="https://blog.csdn.net/wjc1182511338/article/details/82112181" target="_blank" rel="noopener">https://blog.csdn.net/wjc1182511338/article/details/82112181</a>  获得未初始化的变量</p><p>[3] <a href="https://blog.csdn.net/mr_muli/article/details/80868826" target="_blank" rel="noopener">https://blog.csdn.net/mr_muli/article/details/80868826</a></p><p>[4] <a href="https://blog.csdn.net/ArtistA/article/details/52860050" target="_blank" rel="noopener">https://blog.csdn.net/ArtistA/article/details/52860050</a></p><p>[5] <a href="https://zhuanlan.zhihu.com/p/42183653" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42183653</a></p><p>[6] <a href="https://www.quora.com/Is-it-possible-to-only-train-the-final-layer-of-a-Neural-Net-in-TensorFlow-that-was-already-trained" target="_blank" rel="noopener">https://www.quora.com/Is-it-possible-to-only-train-the-final-layer-of-a-Neural-Net-in-TensorFlow-that-was-already-trained</a></p><p>[7] <a href="https://stackoverflow.com/questions/37326002/is-it-possible-to-make-a-trainable-variable-not-trainable" target="_blank" rel="noopener">https://stackoverflow.com/questions/37326002/is-it-possible-to-make-a-trainable-variable-not-trainable</a></p><p>[8] <a href="https://stackoverflow.com/questions/45093499/how-to-fine-tune-weights-in-specific-layers-in-tensorflow" target="_blank" rel="noopener">https://stackoverflow.com/questions/45093499/how-to-fine-tune-weights-in-specific-layers-in-tensorflow</a></p><p>[9] <a href="https://stackoverflow.com/questions/34001922/failedpreconditionerror-attempting-to-use-uninitialized-in-tensorflow" target="_blank" rel="noopener">https://stackoverflow.com/questions/34001922/failedpreconditionerror-attempting-to-use-uninitialized-in-tensorflow</a></p><p>[10] <a href="https://stackoverflow.com/questions/47765595/tensorflow-attempting-to-use-uninitialized-value-beta1-power/47780342" target="_blank" rel="noopener">https://stackoverflow.com/questions/47765595/tensorflow-attempting-to-use-uninitialized-value-beta1-power/47780342</a></p><p>[11] <a href="https://blog.csdn.net/u011961856/article/details/76850335" target="_blank" rel="noopener">https://blog.csdn.net/u011961856/article/details/76850335</a></p><p>[12] <a href="https://blog.csdn.net/abc8350712/article/details/78437250" target="_blank" rel="noopener">https://blog.csdn.net/abc8350712/article/details/78437250</a></p><p>[13] <a href="http://mashangxue123.com/TensorFlow/687648778.html" target="_blank" rel="noopener">http://mashangxue123.com/TensorFlow/687648778.html</a></p><p>[14] <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/slim</a></p><p>[15] <a href="https://cv-tricks.com/tensorflow-tutorial/save-restore-tensorflow-models-quick-complete-tutorial/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://cv-tricks.com/tensorflow-tutorial/save-restore-tensorflow-models-quick-complete-tutorial/?tdsourcetag=s_pctim_aiomsg</a></p><p>[16] <a href="https://github.com/cchen156/Learning-to-See-in-the-Dark" target="_blank" rel="noopener">https://github.com/cchen156/Learning-to-See-in-the-Dark</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> slim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>修改Tensorflow张量指定元素值</title>
      <link href="/2019/01/10/%E4%BF%AE%E6%94%B9tensorflow%E5%BC%A0%E9%87%8F%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E5%80%BC/"/>
      <url>/2019/01/10/%E4%BF%AE%E6%94%B9tensorflow%E5%BC%A0%E9%87%8F%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>引用：</p><p><a href="https://blog.csdn.net/Strive_For_Future/article/details/82426015" target="_blank" rel="noopener">https://blog.csdn.net/Strive_For_Future/article/details/82426015</a></p><p><a href="https://blog.csdn.net/HowardWood/article/details/79587487" target="_blank" rel="noopener">https://blog.csdn.net/HowardWood/article/details/79587487</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Tensorboard监控slim网络中间层输出</title>
      <link href="/2019/01/08/tensorboard%E7%9B%91%E6%8E%A7slim%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%97%B4%E5%B1%82%E8%BE%93%E5%87%BA/"/>
      <url>/2019/01/08/tensorboard%E7%9B%91%E6%8E%A7slim%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%97%B4%E5%B1%82%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>使用tensorboard查看中间层输出结果一般需要在源程序中添加以下几条命令</p><p>1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">summary_op = tf.summary.merge_all()</span><br><span class="line">summary_writer = tf.summary.FileWriter(<span class="string">'./mid_result'</span>, tf.get_default_graph())</span><br></pre></td></tr></table></figure><p>需要添加在sess.run()开始循环迭代之前，不要添加在循环内部，可能会造成多次创建总结数据。</p><p>2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">summary_str = sess.run(summary_op, feed_dict=&#123;in_image: input_full&#125;)</span><br><span class="line">summary_writer.add_summary(summary_str, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>需要添加在sess.run()之后。</p><p>3：</p><p><code>show_feature_map_direct(layer=conv10, layer_name=&quot;conv10&quot;, num_or_size_splits=12, axis=3, max_outputs=3)</code></p><p>在每一个想要查看的中间层代码后，添加如上代码。</p><p>layer: 想要输出的层结果，</p><p>layer_name:输出层的scope/name,</p><p>num_or_size_splits:输出层的层数。</p><p>可以放在卷积层后，也可以放在残差层后：</p><p><code>conv10 = slim.conv2d(conv9, 12, [1, 1], rate=1, activation_fn=None, scope=&#39;g_conv10&#39;)</code></p><p><code>conv10 = tf.add(conv10, add_result, name=&#39;g_add_conv10&#39;)</code></p><p>4:</p><p>添加显示图函数到代码中供调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def show_feature_map_direct(layer, layer_name, num_or_size_splits, axis, max_outputs):</span><br><span class="line">    split = tf.split(layer, num_or_size_splits=num_or_size_splits, axis=axis)</span><br><span class="line"></span><br><span class="line">    for i in range(num_or_size_splits):</span><br><span class="line">        tf.summary.image(layer_name + &quot;-&quot; + str(i), split[i], max_outputs)</span><br></pre></td></tr></table></figure><p>5：</p><p>运行时，在控制台命令行执行tensorboard命令，将会同时记录日志文件到mid_result文件夹中。</p><p><code>tensorboard --logdir=&#39;./mid_result&#39;</code></p><p>浏览器访问<a href="http://127.0.0.1:6006" target="_blank" rel="noopener">http://127.0.0.1:6006</a>  即可看到tensorboard的控制台。</p><p>6：</p><p>如果为远程服务器，可以从本地命令行新建立ssh链接</p><p><code>ssh -L 16006:127.0.0.1:6006 account@server.address</code></p><p>然后在本地浏览器访问<a href="http://127.0.0.1:16006" target="_blank" rel="noopener">http://127.0.0.1:16006</a> 即可查看tensorboard控制台。</p><p>引用：</p><p><a href="https://www.tensorflow.org/guide/summaries_and_tensorboard" target="_blank" rel="noopener">https://www.tensorflow.org/guide/summaries_and_tensorboard</a></p><p><a href="https://zhuanlan.zhihu.com/p/31865749?from_voters_page=true" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31865749?from_voters_page=true</a></p><p><a href="https://www.jianshu.com/p/4e8e5f516d84" target="_blank" rel="noopener">https://www.jianshu.com/p/4e8e5f516d84</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BayerRaw与RGB的转换</title>
      <link href="/2018/11/18/BayerRaw%E4%B8%8ERGB%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/11/18/BayerRaw%E4%B8%8ERGB%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>代码：<a href="https://github.com/zkeenly/articles/blob/master/RAW2RGB.py" target="_blank" rel="noopener">code</a><br>本文采取sony拍摄的arw格式图像测试，测试图像在<a href="https://github.com/cchen156/Learning-to-See-in-the-Dark" target="_blank" rel="noopener">论文</a>中下载：</p><p>bayer图像格式<br><img src="https://user-images.githubusercontent.com/6647857/47952226-e8512f80-dfa6-11e8-8a7a-facbd94c30e6.png" alt="image"><br>由于人眼对GREEN颜色的感知更为强烈，所以一般raw 格式的图像每个2*2矩阵中，都有两个G分量，一个R以及一个B分量，G分量的排列方式可以有所不同，如下图：<br><img width="302" alt="image" src="https://user-images.githubusercontent.com/6647857/47952815-36b6fc00-dfb0-11e8-999f-519c9f004b59.png"></p><p>对于转换为RGB格式，一般采取插值的方法，将原始图像中的R/G/B三个分量，插值到附近，分别产生新的三个矩阵，分别为R,G,B。<br><img width="117" alt="image" src="https://user-images.githubusercontent.com/6647857/47952791-db850980-dfaf-11e8-847b-0751b4fb98b8.png"><br>以下为代码，对于两个G分量采用均值方法优化插值：</p><p><img width="423" alt="image" src="https://user-images.githubusercontent.com/6647857/47952218-c0fa6280-dfa6-11e8-9ce1-1feb84a3008f.png"></p><p>1-自己写的函数最终得到图像结果：<br>放大：<br><img width="600" alt="image" src="https://user-images.githubusercontent.com/6647857/47952892-f0ae6800-dfb0-11e8-9bbb-51b472db5740.png"><br>原图：<br><img width="600" alt="image" src="https://user-images.githubusercontent.com/6647857/47952822-4a626280-dfb0-11e8-8d16-fcea9ab15813.png"></p><p>2-使用sony插件直接查看arw图像的结果：<br>放大：<br><img width="600" alt="image" src="https://user-images.githubusercontent.com/6647857/47952873-d07ea900-dfb0-11e8-9cd6-406e80d583b0.png"><br>原图：<br><img width="600" alt="image" src="https://user-images.githubusercontent.com/6647857/47952832-6f56d580-dfb0-11e8-9277-4f973f0e8fb8.png"></p><p>3-使用python rawpy库函数的postprocess 方法默认参数处理：<br>放大：<br><img width="600" alt="image" src="https://user-images.githubusercontent.com/6647857/47952898-00c64780-dfb1-11e8-974c-28adb36d771e.png"><br>原图：<br><img width="600" alt="image" src="https://user-images.githubusercontent.com/6647857/47952854-990ffc80-dfb0-11e8-9c54-83e15026a3e5.png"></p><p>4-使用learning to see in dark 中的postprocess 方法所设置的参数处理：<br>rgb = raw.postprocess(use_camera_wb=True, half_size=False, no_auto_bright=True, output_bps=16)<br>放大：<br><img width="600" alt="image" src="https://user-images.githubusercontent.com/6647857/47952903-0f146380-dfb1-11e8-82b4-4ef52cd2c49e.png"><br>原图：<br><img width="600" alt="image" src="https://user-images.githubusercontent.com/6647857/47952865-c0ff6000-dfb0-11e8-98dd-013d85bb501a.png"></p><p>最终分析结果：<br>再亮度上：<br>2&gt;3&gt;4&gt;1</p><p>在视觉效果上：<br>4&gt;2&gt;3&gt;1<br>在清晰度上：<br>4=3&gt;2=1<br>在还原RGB方面，使用参数调节后的rawpy.postprocess方法（use_camera_wb）更好。<br>造成以上差异的主要因素还是插值方法的不同：<br>在文章HIGH-QUALITY LINEAR INTERPOLATION FOR DEMOSAICING OF BAYER-PATTERNED COLOR IMAGES 中介绍了更好的插值方法：<br><img width="357" alt="image" src="https://user-images.githubusercontent.com/6647857/47953171-c9599a00-dfb4-11e8-8c12-5343fff0d97f.png"></p><p>引用：<br><a href="https://letmaik.github.io/rawpy/api/rawpy.Params.html" target="_blank" rel="noopener">https://letmaik.github.io/rawpy/api/rawpy.Params.html</a><br><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Demosaicing_ICASSP04.pdf" target="_blank" rel="noopener">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Demosaicing_ICASSP04.pdf</a><br><a href="http://www.imatest.com/docs/raw/" target="_blank" rel="noopener">http://www.imatest.com/docs/raw/</a><br><a href="http://blog.sina.com.cn/s/blog_ebbe6d790101e56e.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_ebbe6d790101e56e.html</a><br><a href="https://blog.csdn.net/peng864534630/article/details/78177211" target="_blank" rel="noopener">https://blog.csdn.net/peng864534630/article/details/78177211</a><br><a href="https://www.cnblogs.com/zhongguo135/p/7755287.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhongguo135/p/7755287.html</a><br>Learning-to-see-in-draking</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tensorflow中slice与cancat的使用</title>
      <link href="/2018/11/18/Tensorflow%E4%B8%ADslice%E4%B8%8Ecancat%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/11/18/Tensorflow%E4%B8%ADslice%E4%B8%8Ecancat%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>两个函数都是卷积神经网络中的常见操作，<br>再修改tf.conrib.slim 程序时，slim 没有自带的slice操作，但是可以直接使用tf的slice操作代替。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = tf.constant([[[1, 1, 1], [2, 2, 2]],</span><br><span class="line">                 [[3, 3, 3], [4, 4, 4]],</span><br><span class="line">                 [[5, 5, 5], [6, 6, 6]]])</span><br><span class="line">tf.slice(t, [1, 0, 0], [1, 1, 3])  # [[[3, 3, 3]]]</span><br><span class="line">tf.slice(t, [1, 0, 0], [1, 2, 3])  # [[[3, 3, 3],</span><br><span class="line">                                   #   [4, 4, 4]]]</span><br><span class="line">tf.slice(t, [1, 0, 0], [2, 1, 3])  # [[[3, 3, 3]],</span><br><span class="line">                                   #  [[5, 5, 5]]]</span><br></pre></td></tr></table></figure></p><p>其中后两个参数为 begin和 size。<br>begin 代表开始位置（每一个维度上从第几个元素开始截取）<br>size 代表每一个维度从begin位置上开始截取多少个元素</p><p>简单的说：<br>例子：<br><code>tf.slice(t, [1, 0, 0], [1, 1, 3])  # [[[3, 3, 3]]]</code><br>中的[1, 0, 0] ：<br>第一个1 代表从行 [[3, 3, 3], [4, 4, 4]] 开始截取。<br>第二个0 代表从[3, 3, 3] 开始截取<br>第三个0 代表从元素3 开始截取<br>中的[1, 1, 3] ：<br>第一个1 代表截取一个元素即[[3, 3, 3], [4, 4, 4]]<br>第二个1 代表截取一个元素即[3, 3, 3]<br>第三个3 代表截取三个元素即3，3，3<br>最终结果还原原始维度为：[[[3, 3, 3]]]</p><p>例子：<br><code>tf.slice(t, [1, 0, 0], [2, 1, 3])  # [[[3, 3, 3]],  [[5, 5, 5]]]</code><br>中的 [1, 0, 0]：<br>第一个1 代表从行 [[3, 3, 3], [4, 4, 4]] 开始截取。<br>第二个0 代表从[3, 3, 3] 开始截取<br>第三个0 代表从元素3 开始截取<br>中的 [2, 1, 3]：<br>第一个2 代表截取两个元素即<br>                 [[3, 3, 3], [4, 4, 4]],<br>                 [[5, 5, 5], [6, 6, 6]]<br>可以视为:<br>x = [3, 3, 3], [4, 4, 4]<br>y = [5, 5, 5], [6, 6, 6]<br>截取了[x,y]<br>第二个1代表上面的每一行(每一个元素x or y)截取一个子元素即<br>                 [[3, 3, 3]],<br>                 [[5, 5, 5]]<br>这里的每个单元素整体是：<br>x = [3, 3, 3]<br>y = [5, 5, 5]<br>第三个3 代表上面的每一个元素截取三个子元素即<br>3, 3, 3<br>5, 5, 5<br>最终结果还原原始维度为：<br>[[[3, 3, 3]],[[5, 5, 5]]]</p><p>在程序中如果没有确定的维度大小，可以用-1代表终止位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conv1 = slim.conv2d(input, 32, [3, 3], rate=1, activation_fn=lrelu, scope=&apos;g_conv1_1&apos;)</span><br><span class="line">conv1 = slim.conv2d(conv1, 32, [3, 3], rate=1, activation_fn=lrelu, scope=&apos;g_conv1_2&apos;)</span><br><span class="line">slice_1 = tf.slice(conv1, [0, 0, 0, 0], [-1, -1, -1, 16])</span><br><span class="line">slice_2 = tf.slice(conv1, [0, 0, 0, 16], [-1, -1, -1, 16])</span><br></pre></td></tr></table></figure></p><p><img width="385" alt="image" src="https://user-images.githubusercontent.com/6647857/48109926-656cf500-e284-11e8-8eee-341ec66cb880.png"></p><p>concat 的用法就比较简单了，但是要注意坐标的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 = [[1, 2, 3], [4, 5, 6]]</span><br><span class="line">t2 = [[7, 8, 9], [10, 11, 12]]</span><br><span class="line">tf.concat([t1, t2], 0)  # [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]</span><br><span class="line">tf.concat([t1, t2], 1)  # [[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]</span><br></pre></td></tr></table></figure></p><p>其中第二个参数0 代表以第1维合并，1代表第二维合并…</p><p><code>concat1 = tf.concat([slice_1, slice_2], axis=3)</code><br>例如上面的slice_1 与slice_2 的合并需要设置axis=3.<br><img width="364" alt="image" src="https://user-images.githubusercontent.com/6647857/48110019-db715c00-e284-11e8-84e3-4eae81c7b618.png"></p><p>引用：<br><a href="https://www.tensorflow.org/api_docs/python/tf/slice" target="_blank" rel="noopener">https://www.tensorflow.org/api_docs/python/tf/slice</a><br><a href="https://www.tensorflow.org/api_docs/python/tf/concat" target="_blank" rel="noopener">https://www.tensorflow.org/api_docs/python/tf/concat</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CNN中的参数量与占用内存计算</title>
      <link href="/2018/11/18/CNN%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%87%8F%E4%B8%8E%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E8%AE%A1%E7%AE%97/"/>
      <url>/2018/11/18/CNN%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E9%87%8F%E4%B8%8E%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>卷积网络的参数计算，实际上就是卷积核的数量统计。<br><img width="581" alt="image" src="https://user-images.githubusercontent.com/6647857/48416886-50182f00-e78c-11e8-8b17-c5d7da6a1bf0.png"><br>这张图很好的体现了卷积网络的过程：<br>假设input为三层，就需要三个卷积核对其分别卷积，之后将卷积结果累加得到一层特征图。<br>如果需要得到2层特征图的结果，就需要3 <em> （三个卷积核） 共需要六个卷积核来生成2层特征图。<br>每个卷积核由3 </em> 3个参数组成，所以上图共需要3 <em> 2 </em>（3 <em> 3）个参数。<br>input层的占用内存为3 </em>（5<em>5），output层的占用内存为2 </em>（3 * 3）。<br>于是就得到下图关于VGG16内存占用以及参数的计算结果：<br><img width="586" alt="image" src="https://user-images.githubusercontent.com/6647857/48417197-1c89d480-e78d-11e8-9c3c-66712274070b.png"></p><p>引用：<a href="http://cs231n.github.io/convolutional-networks/" target="_blank" rel="noopener">http://cs231n.github.io/convolutional-networks/</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CNN中感受野的计算方法</title>
      <link href="/2018/11/18/CNN%E4%B8%AD%E6%84%9F%E5%8F%97%E9%87%8E%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/18/CNN%E4%B8%AD%E6%84%9F%E5%8F%97%E9%87%8E%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>简单的说，感受野就是当前卷积层每个像素点是从多少个input层的像素点通过不断卷积得到的。<br>一般卷积网络越深，每个像素的感受野就越大（反卷积则相反）， 这在目标识别/检测网络设计中起到一个很重要的参考因素。</p><p>计算公式：<br><img width="759" alt="image" src="https://user-images.githubusercontent.com/6647857/48189318-ddb5e200-e37a-11e8-8b1c-fd98ffdb6c89.png"></p><p><img width="761" alt="image" src="https://user-images.githubusercontent.com/6647857/48189462-3e451f00-e37b-11e8-882c-52e7e5030f5d.png"><br>假设有一个5<em>5的input层<br>通过kernel=3</em>3，padding=1，stride=2 的卷积方式<br>将会得到3<em>3的layer1.（下图为layer1元素对应在input layer中的位置）<br><img width="167" alt="image" src="https://user-images.githubusercontent.com/6647857/48199662-c802e580-e397-11e8-95e5-7acf7519d567.png"><br>其中，每一个元素都是input由3</em>3的kernel卷积生成，所以每一个像素的感受野为3</p><p><img width="712" alt="image" src="https://user-images.githubusercontent.com/6647857/48189781-e8bd4200-e37b-11e8-8864-9ba4a98eaac7.png"><br>将此层再通过kernel=3 <em> 3，padding=1，stride=2的卷积方式卷积。<br>将会得到2 </em> 2的layer2。<br><img width="156" alt="image" src="https://user-images.githubusercontent.com/6647857/48199704-ed8fef00-e397-11e8-9ef0-e47e1a5e3234.png"></p><p>此时，每一个元素都是由layer1的3 <em> 3个元素通过3 </em> 3的卷积核生成。<br>所以layer2的每个元素感受野为3 <em> 3个layer1元素的感受野。<br>然而layer1元素在原始数据上对应位置的排列如图：<br><img width="167" alt="image" src="https://user-images.githubusercontent.com/6647857/48199662-c802e580-e397-11e8-95e5-7acf7519d567.png"><br>相当于layer2每个元素都感知了3 </em> 3个layer1元素，然而layer1每个3<em>3在input上的实际感受野为7 </em> 7（每个元素都可以感知周边的九个元素。）<br><img width="172" alt="image" src="https://user-images.githubusercontent.com/6647857/48201743-026f8100-e39e-11e8-937c-39d101f1b506.png"></p><p>那么怎么计算呢，如果规定stride=1的，padding=1，kernel=3的话：每次卷积结果都会是同样尺寸的。<br>每次卷积都是扩大了一个边界的感受野，就是：(kernel-1)大小的区域。<br>那么加上约束stride=s之后，每次stride跳动并不会影响到下一层layer在本层的感受野，但是会影响到下下次layer在本层的感受野。<br>因为当前input-layer1的stride 无论多大，layer1在input上的感受野总是只与卷积核有关。<br>但是当进行到layer1-layer2,需要求知layer2在input上的感受野，就会受到input-layer1的stride影响，stride越大，所影响input的范围就越大（一般stride不会超过(k-1)/2的，这会造成部分元素无法感知）。<br>于是<br>input : r=1<br>input-&gt;layer1 : s=2,k=3,p=1<br>得到layer1感受野为r=r[input] + (k-1)</p><p>layer1-&gt;layer2 : s=2,k=3,p=1<br>得到layer2在input的感受野为r=r[layer1] + (k[1-&gt;2]-1) * s[input-&gt;layer1]</p><p>layer2-&gt;layer3 : s=2,k=3,p=1<br>得到layer3在layer1的感受野为r = r[layer2] + (k[2-&gt;3]-1) <em> s[layer1-&gt;layer2]<br>随着stride的累加，造成的感受野增加量也是成倍的扩大。<br>得到layer3的input感受野为r = r[layer2] + (k[2-&gt;3]-1) </em> s[layer1-&gt;layer2] * s[input-&gt;layer1]</p><p>因此得到一般化的公式：<br>r[current] = r[pre] + (k[pre-&gt;current]-1) <em> s[pre-&gt;current] </em> s[prepre-&gt;pre] <em> … </em> s[input-&gt;layer1]<br>此计算公式与padding是无关的。<br>其中： (k[pre-&gt;current]-1) <em> s[pre-&gt;current] </em> s[prepre-&gt;pre] <em> … </em> s[input-&gt;layer1] 是在上一层感受野基础上多出来的(k-1)边界造成在input上的感受野。</p><p>引用：<br><a href="https://medium.com/mlreview/a-guide-to-receptive-field-arithmetic-for-convolutional-neural-networks-e0f514068807" target="_blank" rel="noopener">https://medium.com/mlreview/a-guide-to-receptive-field-arithmetic-for-convolutional-neural-networks-e0f514068807</a><br><a href="https://mathematica.stackexchange.com/questions/133927/how-to-compute-the-receptive-field-of-a-neuron" target="_blank" rel="noopener">https://mathematica.stackexchange.com/questions/133927/how-to-compute-the-receptive-field-of-a-neuron</a><br><a href="https://stackoverflow.com/questions/35582521/how-to-calculate-receptive-field-size" target="_blank" rel="noopener">https://stackoverflow.com/questions/35582521/how-to-calculate-receptive-field-size</a><br><a href="https://www.reddit.com/r/MachineLearning/comments/6o6cr8/d_how_does_one_calculate_the_receptive_field_of_a/" target="_blank" rel="noopener">https://www.reddit.com/r/MachineLearning/comments/6o6cr8/d_how_does_one_calculate_the_receptive_field_of_a/</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[ACM/算法]探索大海</title>
      <link href="/2018/11/17/ACM-%E7%AE%97%E6%B3%95-%E6%8E%A2%E7%B4%A2%E5%A4%A7%E6%B5%B7/"/>
      <url>/2018/11/17/ACM-%E7%AE%97%E6%B3%95-%E6%8E%A2%E7%B4%A2%E5%A4%A7%E6%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="https://user-images.githubusercontent.com/6647857/46867553-fa342c80-ce57-11e8-864c-bc67a02c0e0c.png" alt="image"></p><p>解决方法：<br>这道题一眼看去可能是深度/广度优先遍历，这样做时间复杂度会比较高，也可以采用并查集的思想，具体是：<br>先把所有的大海的点当作坐标存入list-position_array中，<br>然后将我存入classify_array，<br>对这个position_array 进行遍历，凡是与calssify_array中元素距离等于1的，都移除存入classify_array中。当所有的距离为1的点都遍历完全之后，classify_array 的元素个数就是所能够达到的面积</p><p>这个程序其实还适用于对于目标聚类的算法（可以说算是KNN算法的实现）如下图所示：<br><img src="https://user-images.githubusercontent.com/6647857/46905245-15b83980-cf23-11e8-9b60-46071558f348.png" alt="image"><br>对以上目标聚类<br>下面代码中存入classify_array的时候加入了类别classify_number 元素，如此当一个类别的元素分类完毕之后classify_number +1,继续计算下一个分类。最终会得到带有类别标签的list集合。</p><p>classify_array.append((position_array[0], classify_number))<br><a href="https://github.com/zkeenly/articles/blob/master/%E6%8E%A2%E7%B4%A2%E5%A4%A7%E6%B5%B7.py" target="_blank" rel="noopener">探索大海</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[ACM/算法]五子棋</title>
      <link href="/2018/11/17/ACM-%E7%AE%97%E6%B3%95-%E4%BA%94%E5%AD%90%E6%A3%8B/"/>
      <url>/2018/11/17/ACM-%E7%AE%97%E6%B3%95-%E4%BA%94%E5%AD%90%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<p>问题：<br><img src="https://user-images.githubusercontent.com/6647857/46867024-26e74480-ce56-11e8-93d9-7c106b0321c8.png" alt="image"><br><img src="https://user-images.githubusercontent.com/6647857/46867037-3070ac80-ce56-11e8-999d-e56b22736a24.png" alt="image"></p><p>解决方法：<br>此题尚未完全AC，但是在牛客网另一道五子棋试题中稍加修改是可以AC的，当然是由于样例没有完全分析到的原因<br><a href="https://www.nowcoder.com/practice/a811535fed784ea492b63622c28c75c5?tpId=3&amp;&amp;tqId=10929&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/hackathon/question-ranking" target="_blank" rel="noopener">牛客网-五子棋</a></p><p>这道题其实看起来是比较容易的，做起来也非麻烦的事情，就是每个点判断上下左右是否成立五子棋的标准。<br>但是我有一个比较普适性的且容易扩展的方法来解决，就是采用卷积滤波的方式，采用四个5*5的卷积滤波来对棋盘卷积判定，这样的方法对于六子棋，四子棋之类的都可以很容易扩展。<br>首先构建四个卷积滤波：<br>array_line = [[0, 0, 0, 0, 0],<br>​                [0, 0, 0, 0, 0],<br>​                [1, 1, 1, 1, 1],<br>​                [0, 0, 0, 0, 0],<br>​                [0, 0, 0, 0, 0]]<br>array_long = [[0, 0, 1, 0, 0],<br>​                [0, 0, 1, 0, 0],<br>​                [0, 0, 1, 0, 0],<br>​                [0, 0, 1, 0, 0],<br>​                [0, 0, 1, 0, 0]]<br>array_slant1 = [[1, 0, 0, 0, 0],<br>​                [0, 1, 0, 0, 0],<br>​                [0, 0, 1, 0, 0],<br>​                [0, 0, 0, 1, 0],<br>​                [0, 0, 0, 0, 1]]<br>array_slant2 = [[0, 0, 0, 0, 1],<br>​                [0, 0, 0, 1, 0],<br>​                [0, 0, 1, 0, 0],<br>​                [0, 1, 0, 0, 0],<br>​                [1, 0, 0, 0, 0]]<br>将原始棋盘进行上下左右padding0扩展（由于有可能出现第一行出现五个连续棋子的情况，所有必须要扩展边界。）<br>对逐个元素卷积判定。记录统计所有五子棋的情况个数。</p><p>代码不是很复杂，直接贴上来好了<br><a href="https://github.com/zkeenly/articles/blob/master/%E4%BA%94%E5%AD%90%E6%A3%8B.py" target="_blank" rel="noopener">五子棋</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[ACM/算法]Hilbert曲线</title>
      <link href="/2018/11/17/ACM-%E7%AE%97%E6%B3%95-Hilbert%E6%9B%B2%E7%BA%BF/"/>
      <url>/2018/11/17/ACM-%E7%AE%97%E6%B3%95-Hilbert%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="https://user-images.githubusercontent.com/6647857/46865616-bc7fd580-ce50-11e8-9704-e85b531805b2.png" alt="image"><br><img src="https://user-images.githubusercontent.com/6647857/46865622-c1448980-ce50-11e8-97ea-050ce5104503.png" alt="image"><br><img src="https://user-images.githubusercontent.com/6647857/46865645-d9b4a400-ce50-11e8-9d04-4737ae7fd456.png" alt="image"><br><img src="https://user-images.githubusercontent.com/6647857/46865669-e5a06600-ce50-11e8-9c3d-10fa5cf3138f.png" alt="image"></p><p>解题方法：<br>首先po一个很直观的对hilbert的理解：<br><a href="https://www.bilibili.com/video/av4201747?from=search&amp;seid=12530994814698419444" target="_blank" rel="noopener">https://www.bilibili.com/video/av4201747?from=search&amp;seid=12530994814698419444</a><br>看完这个视频基本上就对这个曲线有所了解了，解法当然也就显而易见，就是首先构建一个基础的2<em>2的hilbert曲线轨迹<br><img src="https://user-images.githubusercontent.com/6647857/46866276-4c268380-ce53-11e8-8eac-86d0327bdb34.png" alt="image"><br>由于要求输出结果为顺序，定义一个以上轨迹顺序的矩阵base_box：<br>[[2 3]<br> [1 4]]<br>然后将这个base_box 扩展到4</em>4的矩阵中中上面两个2<em>2矩阵，<br>对于下面的连个2</em>2 矩阵，左下的矩阵进行逆时针旋转，右下的矩阵进行顺时针旋转。<br>然后将旋转之后的数字顺序反转一下<br>将左上2<em>2矩阵+4，右上+8，右下+12<br>就得到了hilbert矩阵<br>[[ 6  7 10 11]<br> [ 5  8  9 12]<br> [ 4  3 14 13]<br> [ 1  2 15 16]]<br>最终这个4</em>4的矩阵就做好了，下一次继续以此办法迭代将会得到8*8的矩阵。<br>[[22 23 26 27 38 39 42 43]<br> [21 24 25 28 37 40 41 44]<br> [20 19 30 29 36 35 46 45]<br> [17 18 31 32 33 34 47 48]<br> [16 13 12 11 54 53 52 49]<br> [15 14  9 10 55 56 51 50]<br> [ 2  3  8  7 58 57 62 63]<br> [ 1  4  5  6 59 60 61 64]]</p><p>附上code：<br><a href="https://github.com/zkeenly/articles/blob/master/hilbert.py" target="_blank" rel="noopener">hilbert</a><br>此程序输入输出：<br>输入：一个数字n<br>输出：n个hilbert矩阵，二阶，四阶，八阶…<br>如需题目输入输出样式可自行调节</p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于深度学习的“微博人像自动识别转发机器人”设计</title>
      <link href="/2018/11/17/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E2%80%9C%E5%BE%AE%E5%8D%9A%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%9D%E8%AE%BE%E8%AE%A1/"/>
      <url>/2018/11/17/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E2%80%9C%E5%BE%AE%E5%8D%9A%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%9D%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>源代码：<a href="https://github.com/zkeenly/fanfou_robot" target="_blank" rel="noopener">https://github.com/zkeenly/fanfou_robot</a></p><h1 id="V1-0更新："><a href="#V1-0更新：" class="headerlink" title="V1.0更新："></a>V1.0更新：</h1><h2 id="一，对网络结构调整："><a href="#一，对网络结构调整：" class="headerlink" title="一，对网络结构调整："></a>一，对网络结构调整：</h2><p>1，通过大量实验测试，最终在RESnet50与VGG16中使用VGG16。</p><p><img src="https://user-images.githubusercontent.com/6647857/43085632-089b2e82-8ece-11e8-9356-4d07fe9e4b6d.png" alt="image"></p><p>2，通过观察爬取的数据集特征，将训练数据集分为5类，分别为”人像“，“食物”，“文字”，“动物”，“风景”。</p><p>3，训练100次epoch</p><p>4，batchsize=24</p><p>5，imagesize = 120</p><p>最终实际运行准确度更加趋近稳定，对于动物误识别为人的概率大大减小。</p><p><img src="https://user-images.githubusercontent.com/6647857/43085653-19c0ce6a-8ece-11e8-9637-932df9c8fd4f.png" alt="image"></p><h2 id="二，增加更多的功能："><a href="#二，增加更多的功能：" class="headerlink" title="二，增加更多的功能："></a>二，增加更多的功能：</h2><p>1，将屏蔽转发用户写入为block_list文件，从文件中读取屏蔽用户。</p><p>2，当用户发送 “@深绘里 -quit”时，可以将自己列入屏蔽列表中，当发送”@深绘里 -join“，可以重新参与被检索。</p><p>3，当用户quit or join，通过私信告知用户。</p><p>4，为了提高检测精准度，预测图像的时候，对于 长 or 高（比例大于1：1.3） 的图像裁剪为上，中，下，以及整张图resize为正方形的四张图片进行预测，如果有一张检测为人像，并且另外三张没有同时检测为其他同一类型的图片，则正确分类为人像。</p><p>5，自动生成日志log文件，存放于log/log_.txt中。</p><p>6，修补bug（修改为运行时强制使用CPU运行，不占用GPU显存）。</p><p>7，修正被黑名单私信发送失败异常。</p><h1 id="程序逻辑设计概要"><a href="#程序逻辑设计概要" class="headerlink" title="程序逻辑设计概要"></a>程序逻辑设计概要</h1><p>本文实验采用Python+Keras作为主要语言，使用饭否API接口实现对微博用户上传的图片实时监控，通过多层卷积神经网络对采集图像进行识别，图像符合人群画像标准，则转发。通过对神经网络训练，识别准确率可达到82.5%。点击<a href="http://fanfou.com/uarepretty" target="_blank" rel="noopener">这里</a>查看微博链接。</p><h1 id="卷积神经网络设计"><a href="#卷积神经网络设计" class="headerlink" title="卷积神经网络设计"></a>卷积神经网络设计</h1><pre><code>本文采用对Lenet经典神经网络改进网络，网络结构如下：</code></pre><p><img src="https://user-images.githubusercontent.com/6647857/43085668-23d52bd0-8ece-11e8-9840-60f3ab0895bb.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># first set of CONV -&gt; RELU -&gt; POOL layers</span><br><span class="line">model.add(Conv2D(20, (5, 5), padding=&quot;same&quot;, input_shape=inputShape))</span><br><span class="line">model.add(Activation(&quot;relu&quot;))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))</span><br><span class="line"># second set of conv relu pool layers</span><br><span class="line">model.add(Conv2D(50, (5, 5), padding=&quot;same&quot;))</span><br><span class="line">model.add(Activation(&quot;relu&quot;))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))</span><br><span class="line"># triple set of conv relu pool layers</span><br><span class="line">model.add(Conv2D(20, (5, 5), padding=&quot;same&quot;))</span><br><span class="line">model.add(Activation(&quot;relu&quot;))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))</span><br><span class="line"># first (only) set of FC relu layers</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(500))</span><br><span class="line">model.add(Activation(&quot;relu&quot;))</span><br><span class="line"># softmax classifier</span><br><span class="line">model.add(Dense(classes))</span><br><span class="line">model.add(Activation(&quot;softmax&quot;))</span><br></pre></td></tr></table></figure><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><p>对数据集采取二分类划分，类别为人像和非人像。数据集收集自饭否网。共计2168张图片，为了提高人像识别度，其中人像大于1.3：1尺寸的图像通过裁剪为三个等比例正方形方法扩展为共计489张。</p><h1 id="自动转发系统设计"><a href="#自动转发系统设计" class="headerlink" title="自动转发系统设计"></a>自动转发系统设计</h1><pre><code>转发系统采用python语言设计，通过饭否API （https://github.com/FanfouAPI/FanFouAPIDoc/wiki）获取系统微博信息。提取信息中的图像数据，使用训练好的model模型进行预测图像分类，若属于人像分类则通过API自动转发。</code></pre><p>自动转发系统日志：<br><img src="https://user-images.githubusercontent.com/6647857/43085860-9f39dcb2-8ece-11e8-96c6-ea600aefb7ca.png" alt="image"><br><img src="https://user-images.githubusercontent.com/6647857/43085874-a2af5354-8ece-11e8-9322-0d3916497a27.png" alt="image"></p><h1 id="机器人识别效果"><a href="#机器人识别效果" class="headerlink" title="机器人识别效果"></a>机器人识别效果</h1><p>通过35次epoch 迭代，训练准确度达到89%左右，验证准确度达到83%左右。由于采取验证图像数据集过于小，所以可以看出图中验证准确度波动较大，且loss较高。</p><p><img src="https://user-images.githubusercontent.com/6647857/43085887-aa83ba98-8ece-11e8-94dd-6ab0ed81e16c.png" alt="image"><br><img src="https://user-images.githubusercontent.com/6647857/43085903-b3a38be4-8ece-11e8-92f9-890dec21d1f1.png" alt="image"><br><a href="http://fanfou.com/uarepretty/" target="_blank" rel="noopener">http://fanfou.com/uarepretty/</a></p><h1 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h1><pre><code>虽然对于人像可以准确的识别，但是对于一些类人像特征的物体，如猫等。也会被误识别为人像并转发。</code></pre><p><img src="https://user-images.githubusercontent.com/6647857/43085923-bd4db520-8ece-11e8-96d6-ae4bc9adc08f.png" alt="image"></p><pre><code>其主要原因是网络结构过于浅，无法学习到更细节的特征，仅学习到了如眼睛，脸轮廓等。对于皮肤光滑程度没有很好的识别。如果采取更深层次的网络如ResNet50将会得到更好的效果。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 饭否 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【生活记录】崴脚的治疗和恢复经历</title>
      <link href="/2018/11/16/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95-%E5%B4%B4%E8%84%9A%E7%9A%84%E6%B2%BB%E7%96%97%E5%92%8C%E6%81%A2%E5%A4%8D%E7%BB%8F%E5%8E%86/"/>
      <url>/2018/11/16/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95-%E5%B4%B4%E8%84%9A%E7%9A%84%E6%B2%BB%E7%96%97%E5%92%8C%E6%81%A2%E5%A4%8D%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>2018年5月15日，在教学楼里下楼时，不经意之间突然听到一声巨响，发现是崴到脚了。随之而来的是剧烈的疼痛和肿胀。当时拖着肿胀的脚艰难的走到校医务室，简单诊断后，建议转到672骨科医院进一步拍摄CT诊断是否有骨折。此时打车到672医院，同时联系朋友前去接应。</p><p>到672医院后，挂号，就诊，拍摄CT查看无骨折。建议回去冰敷修养并建议使用支具支撑（医院收费700，当时并没有购买），腿抬高修养半月。开了几瓶药酒和恢复药物便回校了。</p><p>回去之后并没有严格的冰敷，因为感觉找冰还是有点难度的，其实事后想一想还是可以找到的，各种奶茶店或者买个雪糕也可以的。但是当时仅用冷水敷了几天，这大概也延长了恢复时间。另外支具在五天后意识到还是需要一个的，因为睡觉实在是不舒服，网购了支具固定后便方便了很多。另外推荐扶他林，对于轻度崴脚真的好用，止痛效果很好。</p><p>总结下来前期的恢复流程最好是：尽快冰敷1-2天+支具固定卧床抬高2周+双拐+后期持续热敷。</p><p>但是自身当时没有意识，各个流程都推迟了好多天。这可能也导致恢复缓慢的原因。一直持续到8月才可以正常走路（可缓慢行走），11月才基本恢复正常（但目前仍未尝试跑步等剧烈运动，且冷天需要佩戴脚护踝不能受冻否则会有隐痛，这可能是留下的后遗症吧，需要更长的时间恢复以及平时注意保护）。</p><p>希望有崴到脚的朋友引以为戒。另外无痛感后需要进行适当的运动恢复肌肉的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 杂事 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【生活记录】武汉大学口腔医院经历（根管治疗/拔牙/种植牙）</title>
      <link href="/2018/11/15/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95-%E6%AD%A6%E6%B1%89%E5%A4%A7%E5%AD%A6%E5%8F%A3%E8%85%94%E5%8C%BB%E9%99%A2%E6%B2%BB%E7%96%97%E7%BB%8F%E5%8E%86%EF%BC%88%E6%A0%B9%E7%AE%A1%E6%B2%BB%E7%96%97-%E6%8B%94%E7%89%99-%E7%A7%8D%E6%A4%8D%E7%89%99%EF%BC%89/"/>
      <url>/2018/11/15/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95-%E6%AD%A6%E6%B1%89%E5%A4%A7%E5%AD%A6%E5%8F%A3%E8%85%94%E5%8C%BB%E9%99%A2%E6%B2%BB%E7%96%97%E7%BB%8F%E5%8E%86%EF%BC%88%E6%A0%B9%E7%AE%A1%E6%B2%BB%E7%96%97-%E6%8B%94%E7%89%99-%E7%A7%8D%E6%A4%8D%E7%89%99%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文首发于简书，现转到个人博客，经验分享以及记录，非技术文章。</p><h3 id="前前言："><a href="#前前言：" class="headerlink" title="前前言："></a>前前言：</h3><blockquote><p>事情稍许久远，有些细节也许记忆不清。记录下来供对根管治疗，种植牙，牙齿外伤，智齿拔除等有疑问的患者参考，有任何疑问可留言交流。<br>本文部分图片可能引起不适，希望有必要的读者【谨慎考虑】后再阅读。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48845303-1f14ab80-edd7-11e8-8312-e1d9b2de741f.png" alt="image"><br><code>武大口腔就医指导表格</code></p><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><blockquote><p>意外总是突然的。2017年9月8日，本该是研究生开学初期最愉快的一段时期。然而一场意外悄然而来，晚10点后，于校内骑车摔伤。瞬间像梦境一般，血流不止，感受到多颗牙齿的严重折断损伤（想象被摔得满地找牙的画面感）。同时意识到事情的严重性，于第一时间寻找校医院。一番折腾，感谢校园保卫部，校医院以及舍友的帮助下。成功转院至广州军区武汉总医院急诊。</p></blockquote><h3 id="广州军区武汉总医院治疗经历"><a href="#广州军区武汉总医院治疗经历" class="headerlink" title="广州军区武汉总医院治疗经历"></a>广州军区武汉总医院治疗经历</h3><h4 id="2017-09-08-初次诊治"><a href="#2017-09-08-初次诊治" class="headerlink" title="2017/09.08 初次诊治"></a>2017/09.08 初次诊治</h4><blockquote><p>当晚急诊，医生检查结果牙齿多颗纵折/冠折+下颌骨具有骨折隐患+面部（下巴）外伤。在医生的建议下，先做了伤口的清洗与缝合上药（这里缝合使用的是普通缝合线，会留下伤疤。后面经过出租司机提醒，或许武大口腔可以使用美容线缝合，伤疤更小。不过我的伤口在下巴， 也就有点无所谓的感觉，除了剃胡子不太方便。），然后拍摄CT检查骨折隐患（报告单如下）。报告单显示未看到明显骨折。在医生的建议下于次日再进行三维重建CT，确认隐患。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48845335-3489d580-edd7-11e8-9229-875474ce221f.png" alt="image"><br><code>伤口缝合后愈合图，可以看到缝合部分不生长胡须，且有疤痕</code></p><p><img src="https://user-images.githubusercontent.com/6647857/48845386-52573a80-edd7-11e8-8ae3-0ff3f8ac4057.png" alt="image"><br><code>费用清单</code></p><p><img src="https://user-images.githubusercontent.com/6647857/48845397-5d11cf80-edd7-11e8-9b9d-b44579afa226.png" alt="image"><br><code>报告清单</code></p><h4 id="2017-09-09-三维重建"><a href="#2017-09-09-三维重建" class="headerlink" title="2017.09.09 三维重建"></a>2017.09.09 三维重建</h4><blockquote><p>凌晨回到寝室休息之后，于次日清晨再次来到广州军区武汉总医院（小插曲：打车的时候遇见一位自称是医生的滴滴司机说：你这个情况应该到武汉口腔医院啊，哪边治疗效果更好，于是在司机的建议下去了口腔医院，拿号（普通号）排队，当时医生并没有考虑到骨折问题，只看了牙齿说要根管治疗（最严重的26）。但是当时考虑医保问题，遂暂缓治疗，回到广州军区总医院复查），要再次感谢辅导员和同学的帮助。这次拍摄了三维CT ，以及换药。三维CT需要等2天后再出片，此时家人也赶过来了，这两天外伤换药等片。三维重建费用较高。<br>tips: 三维重建这个CT，在武大口腔做的比较好，后面会有对比图。武大口腔的CT可以生成立体图片，甚至可以刻盘保存，而广州军区这里只有多方位的图片，视觉效果有点差。两个医院的实力/设备还是有很大差距的。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48845418-6733ce00-edd7-11e8-84d6-e4aebd3f1a43.png" alt="image"><br><code>费用清单</code></p><h4 id="2017-09-12-住院广州军区武汉总医院"><a href="#2017-09-12-住院广州军区武汉总医院" class="headerlink" title="2017/09/12 住院广州军区武汉总医院"></a>2017/09/12 住院广州军区武汉总医院</h4><blockquote><p>住院期间，在医生的建议下，对治疗下颌骨骨折做了颌间牵引手术（就是在牙床上打钉子，用皮筋将上下牙齿牵引起来，使牙齿，颌骨无法活动）保持一个月后拆除牵引线以及钉子。一开始医生使用了八个牵引钉子，四个牵引线。但是有一个位置骨质疏松，无法固定牵引钉。故最终使用三个皮筋牵引（这里其实个人感觉两个牵引线，四个钉子就足够了，多打了四个孔，痛苦万分）。皮筋的牵引力都很大，一开始受不了痛苦（牙齿外伤有冠折纵折），遂开了洛索洛芬钠 释缓片。由于颌间牵引，所以吃饭全部为流食（后面痛苦的经历就是喝了一个月的豆浆/豆沫！！！连米粥都喝不成）。在医院输液静养一周后办理出院手续，此时下巴外伤也已经拆线（不可思议的是我在住院期间还去考了PET3，佩服自己的willpower）。<br>tips:做颌间牵引是有后遗症的，就是骨头不会完全对齐，张口左侧骨头会有异响（不知道以后会不会完全恢复如初，恢复到正常使用应该没问题），对于后期的咬合恢复很慢（我不太确定如果手术使用钢板固定会不会好一些，这样可能会留下伤疤）。而且牙齿中缝目前无法对齐。不知和颌骨损伤是否有关系。稍微偏差2mm。不过影响不太大。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48845434-7155cc80-edd7-11e8-90ee-11e725e9f032.png" alt="image"><br><code>正常咬合下侧牙齿有向右轻微偏移</code></p><p><img src="https://user-images.githubusercontent.com/6647857/48845437-761a8080-edd7-11e8-9498-f84b653ec57f.png" alt="image"><br><code>洛索洛芬缓释片</code></p><p><img src="https://user-images.githubusercontent.com/6647857/48845445-7d418e80-edd7-11e8-975c-dacf30e156d9.png" alt="image"><br><code>可以看出在牙床上打了四个钉子（看起来像是打在了牙齿上），右侧箭头处有明显骨折线</code></p><p><img src="https://user-images.githubusercontent.com/6647857/48845451-816dac00-edd7-11e8-8988-c0cb4c3861ee.png" alt="image"><br><code>可以看到，牵引钉子已经拆除，颌骨骨折线也有所愈合。</code></p><p><img src="https://user-images.githubusercontent.com/6647857/48845471-8df20480-edd7-11e8-863b-5dc7971b3a00.png" alt="image"><br><code>出院小结</code></p><blockquote><p>其后多次拍摄影像图，直至骨折恢复后于2018年后开始于武汉大学口腔医院治疗牙齿损伤。</p></blockquote><h3 id="武汉大学口腔医院治疗牙齿"><a href="#武汉大学口腔医院治疗牙齿" class="headerlink" title="武汉大学口腔医院治疗牙齿"></a>武汉大学口腔医院治疗牙齿</h3><blockquote><p>2017/11/17 这是骨折逐渐恢复后第一次来武汉大学口腔医院寻求牙齿损伤的治疗方法。并拍摄3维CT影像。可以看出多颗牙齿折断。当时由于张口仍有一定程度的受限，所以暂缓治疗。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48845483-93e7e580-edd7-11e8-8b1e-66960bacdb26.png" alt="image"><br><code>影像图</code></p><p><img src="https://user-images.githubusercontent.com/6647857/48845490-99ddc680-edd7-11e8-9ffb-84d29b7ee164.png" alt="image"><br><code>可以切换视角的3D影像图</code></p><h4 id="2018-01-25-确认治疗方案"><a href="#2018-01-25-确认治疗方案" class="headerlink" title="2018/01/25 确认治疗方案"></a>2018/01/25 确认治疗方案</h4><blockquote><p>多次拜访武汉大学口腔医院后，最终确认治疗方案。<br>1，洗牙；2，拔除26；3，16/45根管治疗。其他暂缓。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48845503-a06c3e00-edd7-11e8-9531-75e932f028f0.png" alt="image"><br><code>整体建议</code></p><h4 id="2018-03-06-拔牙"><a href="#2018-03-06-拔牙" class="headerlink" title="2018/03/06 拔牙"></a>2018/03/06 拔牙</h4><blockquote><p>犹豫了许久之后，决定先拔除根折无法恢复的26牙齿，本来觉得是很难的事情，因为上牙床骨头稀少，怕拔除时候残片进入上颌窦。所以等主治医师亲自拔牙。打上麻醉之后并没有太多痛感，过程也出乎意料的顺利（10分钟左右）。经过不断晃动就拔掉了根折牙齿26。费用大约800<br>tips:其实有一种传统的方法，自体牙移植，可以将智齿拔除移动到缺失牙齿的位置，有一定的存活概率，看了不少的论文文献。有的说需要外部根管治疗再移植，有的说可以直接移植成活。最后问了口腔医院，说现在都不做这个了。其实有点遗憾，应该多找一找别的医院。可能有的医院是可以做这个手术的，据说是因为成本低，工艺复杂，所以医生都不想做。<br>ref：<a href="https://www.zhihu.com/question/39629006" target="_blank" rel="noopener">https://www.zhihu.com/question/39629006</a>  <a href="https://www.zhihu.com/question/34012960" target="_blank" rel="noopener">https://www.zhihu.com/question/34012960</a><br>看到又有新的成功案例，不禁更加后悔当时没有多找一下了。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48845513-a8c47900-edd7-11e8-85b5-828f33ee607e.png" alt="image"><br><code>一些参考文献</code></p><p><img src="https://user-images.githubusercontent.com/6647857/48845530-ae21c380-edd7-11e8-9b83-7c27506cb2ee.png" alt="image"><br><code>恐怖的拔牙工具与根折残片</code></p><h4 id="2018-03-20-根管治疗"><a href="#2018-03-20-根管治疗" class="headerlink" title="2018/03/20 根管治疗"></a>2018/03/20 根管治疗</h4><blockquote><p>这是最近的事情了，做了两个牙齿的根管治疗，都很顺利。16找的主任医生，采用显微镜根管治疗。花费比较高，但是技术很好。根管两次成功，中间相隔20天（由于医生比较忙），第一次开髓，第二次填充。第二次一般不用打麻药，会有点疼。疼到不想再来第二次的那种！费用大约3000左右<br>其后五月份做了45的根管治疗，这次没有找主任医生，而是副主任。也是两次，间隔一周，很顺利。没有用到显微镜。全部费用大约1000左右</p></blockquote><h4 id="2018-06-07-瘘管"><a href="#2018-06-07-瘘管" class="headerlink" title="2018/06/07 瘘管"></a>2018/06/07 瘘管</h4><blockquote><p>5.20下巴出现瘘管，怀疑是牙源性瘘管。<br>在线问诊后，又询问校医院，说可能是缝针的排异反应。观察数日后于6.7日有所好转。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48845663-140e4b00-edd8-11e8-9c80-39fbd35d96e1.png" alt="image"><br><code>咨询在线医生</code></p><h4 id="2018-06-11-武大口腔瘘管咨询"><a href="#2018-06-11-武大口腔瘘管咨询" class="headerlink" title="2018.06.11 武大口腔瘘管咨询"></a>2018.06.11 武大口腔瘘管咨询</h4><blockquote><p>口腔医院检查瘘管，普通号(今天大屏幕叫号器坏了，真是郁闷)，拍摄曲面断层推测不是牙源性瘘管。应该是缝针反应，手术取出需要800左右。决定先观察一段时间，不行就去学校开个转诊再去。</p></blockquote><p><img width="247" alt="image" src="https://user-images.githubusercontent.com/6647857/48849235-e5e13900-ede0-11e8-9cd3-803468abdfff.png"><br><code>44根折痕迹反而不明显了。</code></p><p><img src="https://user-images.githubusercontent.com/6647857/48849245-ee397400-ede0-11e8-9898-802dbad69c33.png" alt="image"><br><code>曲面断层</code></p><blockquote><p>另外咨询了修复科，牙套价格为1000-4000不等，分别为金属，贵金属，烤瓷牙冠，全瓷牙冠。纠结做哪一种中。</p></blockquote><h4 id="2018-07-01-瘘管好转"><a href="#2018-07-01-瘘管好转" class="headerlink" title="2018.07.01 瘘管好转"></a>2018.07.01 瘘管好转</h4><blockquote><p>瘘管好转，留下一点黑斑，无脓包现象。</p></blockquote><h4 id="2018-07-09-下颌骨弹响"><a href="#2018-07-09-下颌骨弹响" class="headerlink" title="2018.07.09 下颌骨弹响"></a>2018.07.09 下颌骨弹响</h4><blockquote><p>下颌骨咀嚼疼痛，但是张口，平时不动并不痛。去武大口腔咨询，回复建议不要熬夜，不要吃硬物观察两周情况依旧就拍片检查。<br>7.14 依旧疼痛。早餐吃的三明治，无法完全咀嚼。<br>大约7.20 有所好转。</p></blockquote><h4 id="2018-07-16-咨询种植牙"><a href="#2018-07-16-咨询种植牙" class="headerlink" title="2018.07.16 咨询种植牙"></a>2018.07.16 咨询种植牙</h4><blockquote><p>咨询种植牙，花了366又拍了cbct 。和上次的差不多，说可以种植。种植的时候需要增加骨粉，大概是14000+2000左右。时间10个月左右。﻿另外cbct中看到44根折线没有以前明显了，暂时还是不管44了。种植科的专家号很少，都要预约，副主任在10月了，主任在明年3月了真的是要尽早预约的 。<br>最终预约了白轶医生 11.5的副主任号</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48849513-7c155f00-ede1-11e8-9cff-7cd3ce840459.png" alt="image"><br><code>名片</code></p><h4 id="2018-08-26-拔智齿"><a href="#2018-08-26-拔智齿" class="headerlink" title="2018.08.26 拔智齿"></a>2018.08.26 拔智齿</h4><blockquote><p>一直感觉智齿有点不舒服，但是也没有很疼，就是像没有刷干净牙齿，卡了东西一样，今天终于决定去拔掉一颗智齿。<br>这次拔掉的是38，挂的副主任吴杨的号。拔牙的是他的一个实习生，可能是我的情况不是很复杂的原因吧。用一个一字螺丝刀一样的东西，在牙床边缘翘了几下就掉了。拔掉的牙齿忘了拍照，牙齿的型态和下面的图片有点相似（几个牙根连在一起了，不像27，三个压根很明显），费用一共是400左右。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48849563-94857980-ede1-11e8-962c-d4fe0d81a2a9.png" alt="image"><br><code>智齿（网图）</code></p><h4 id="2018-09-07-拔另一颗智齿"><a href="#2018-09-07-拔另一颗智齿" class="headerlink" title="2018.09.07 拔另一颗智齿"></a>2018.09.07 拔另一颗智齿</h4><blockquote><p>挂了个普通号，﻿费用又是400左右，本来可以在学校拔的的，但是当天学校新生体检不接受挂号，加上实习工作日少有时间，还是去了武大口腔 这个牙齿的形态还是比较正常的。拔完之后吃了几天药，现在一周过去稍微好点了。不过有次吃东西感觉点进去米饭一样，然后牙签挖了下给捅进去了？感觉现在都没出来，以后拔牙吃饭掉进去东西千万不要乱搞，漱口就可以。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48849593-a7984980-ede1-11e8-80c7-200d2be9db09.png" alt="image"><br><code>智齿图</code></p><h4 id="2018-10-24-程序员之日"><a href="#2018-10-24-程序员之日" class="headerlink" title="2018.10.24 程序员之日"></a>2018.10.24 程序员之日</h4><blockquote><p>在今天这个程序员之日，我做了一个重大的决定，就是拔掉44牙齿，经过长久的忍耐与对抗，终于下定决心拔掉这个根折的牙齿。拔牙之前签订了一个《可吸收生物膜临床试验》协议，简单来说就是参与临床试验，可以省去将来种植牙植入骨粉的钱，考虑到不会有太严重的副作用就参与了。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48849613-b252de80-ede1-11e8-92ba-669e1a5519c6.png" alt="image"><br><code>临床试验</code></p><blockquote><p>然后体检了血液等，今天来做手术拔牙。由于长期滞留的根折牙齿，拔牙的时候并不是很顺利，牙冠部分首先被拔出来，然后用各种工具去挖里面的牙根，牙根和骨头有了可能有了骨粘连，大概花了20分钟反复尝试才最终拔出来，特别担心之前骨折的地方会不会受到影响。</p></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/48849629-baab1980-ede1-11e8-80f8-226e096de4bb.png" alt="image"><br><code>感觉上好像不是一个完整的牙根。。难道是有残根留在了里面？</code></p><blockquote><p>之后就是植入骨粉，大概五分钟的时间，像是用刀子在刮牙槽骨一样的感觉..  然后覆生物膜，缝针，去拍了个CBCT，结束。真是个痛苦的经历啊。最后这次的费用是200拔牙 + 500骨粉手术费，CBCT属于临床试验费用，骨粉的材料费用也免除了。后续还会有600的回访补贴返还。</p></blockquote><h4 id="2018-11-19-种植牙"><a href="#2018-11-19-种植牙" class="headerlink" title="2018.11.19 种植牙"></a>2018.11.19 种植牙</h4><blockquote><p>到目前为止，终于基本上结束了牙齿的治疗过程，要进入到修复阶段了。<br>再11.5日的时候就咨询过白轶医生，定下来的方案是13000的种植体+上颌窦提升手术+骨粉=预计17000左右。<br>种植体有多种不同类型，但是基本上没必要特意选择，价格的差距主要是表面处理不同，一般良好的牙槽骨以及恢复速度是对表面处理没有太大要求的，所以选择了13000的种植体，还有1.5W 以及1.8W的。<br>种植牙所在的手术间是内部的独立手术室，进去之前需要换鞋，保证了环境的干净。我记得查的白轶医生是男医生，然后给我手术的是女医生，难道是我记错了吗。其实整个过程还是比较顺利的， 医生说上颌窦的膜比较薄，容易穿透，最后还是成功植入了。<br>首先打麻药，消毒，用布把眼睛身体都盖住，只留出嘴巴。用小钻头钻牙槽骨，然后用锤子之类的东西再孔内敲击，进行上颌窦内提升（我之前查的以为是外提升，看了视频真的是吓了一跳，内提升还好，就是不断敲击，有点恐怖，但是伤口并不大，然后放入种植体。完了之后打了三天的消炎针 ，吃了戴芬止痛药。止痛药必须要吃，不然真的会痛到睡不着的。<br>此次一期费用约8000左右，二期是半年后进行牙冠修复，希望可以一切顺利。</p></blockquote><h4 id="2018-12-04-种植牙-拆线复查"><a href="#2018-12-04-种植牙-拆线复查" class="headerlink" title="2018.12.04 种植牙-拆线复查"></a>2018.12.04 种植牙-拆线复查</h4><blockquote><p>最近懒床严重，九点才起床。到医院已经是接近10点，本来不确定还能不能挂到号，结果人还是很少的， 直接来复诊挂号，前面0人排队，很快就到了。缴费100，拍片，不用取，直接上来护士拆线即可。<br>CT片上这张图看起来种植体胖胖的，不过可能后排牙齿都是这样的吧。<br>接下来是6个月后来做二期手术，大概5月中旬，需要提前打电话与白医生预约。顺便夸一下护士小姐姐真的好温柔啊（捂脸<br><img src="https://user-images.githubusercontent.com/6647857/49419490-038ba680-f7c2-11e8-84fc-df9bc58893fa.jpg" alt="img_20181204_100118"><br><img width="398" alt="image" src="https://user-images.githubusercontent.com/6647857/49419769-49953a00-f7c3-11e8-8afe-fef480815c26.png"></p></blockquote><h4 id="2019-02-01-颞下颌关节症状复发。"><a href="#2019-02-01-颞下颌关节症状复发。" class="headerlink" title="2019.02.01 颞下颌关节症状复发。"></a>2019.02.01 颞下颌关节症状复发。</h4><blockquote><p>奇怪的是，撞伤骨折的是左侧颌关节，过年的时候疼痛的反而是右边的颌关节。主要表现为张口疼痛，咬合疼痛。热敷之后会有所好转，准备到学校之后再好好看一下。另外，牙齿的排列先比以前上下中缝之间的差距也更大了一些，不知道是拔牙的原因还是颌关节的原因。<br><img src="https://user-images.githubusercontent.com/6647857/53170344-de694000-361a-11e9-9521-a63c402f1428.png" alt="image"></p></blockquote><h4 id="2019-02-22-颌关节复查"><a href="#2019-02-22-颌关节复查" class="headerlink" title="2019.02.22 颌关节复查"></a>2019.02.22 颌关节复查</h4><blockquote><p>去医院检查颌关节，医生说是颞下颌关节不可复盘移位。</p><p>拍了造影和CBCT，显示颌骨部分有磨损。</p><p><img src="https://user-images.githubusercontent.com/6647857/53227205-9567c900-36b8-11e9-8ac3-27886e973f9b.png" alt="image"><br><code>左侧颌骨</code><br><img src="https://user-images.githubusercontent.com/6647857/53227308-db249180-36b8-11e9-8b48-f8e81720fd37.png" alt="image"><br><code>右侧颌骨</code><br>可以看到右侧颌骨明显更加毛糙一些。医生说是关节处骨头磨损严重，表面的一些物质磨损掉了所以会感到疼痛，建议打透明质酸针看看疗效。或者自己修养不要乱动。<br>让我很困惑的是不知道什么原因就成这样了，真的很烦躁了。</p></blockquote><h4 id="2019-03-06-牙冠修复-下颌骨情况"><a href="#2019-03-06-牙冠修复-下颌骨情况" class="headerlink" title="2019.03.06 牙冠修复/下颌骨情况"></a>2019.03.06 牙冠修复/下颌骨情况</h4><blockquote><p>其实前几天就想去做16牙齿的牙冠修复了，但是每次都起床起晚了，昨天是7点中出宿舍，到医院大概七点半了，排队伍的人已经挤满了大厅。觉得还是放弃了，于是今天5.30就起床，6.50到医院排队。这就让我想起了旅行者困境问题，明明7.30才开始挂号，每个人都想我如果提前1分钟就可以排在90%的人前面，当所有人都这么想，于是，硬生生地大家一起多排队半个小时（是不是以后挂号都要带马扎。<br>来到医院之后首先挂了4楼修复科室的专家号，修复科医生建议做牙冠修复（金属烤瓷1k+,贵金属烤瓷3k+，全瓷4k+）。因为之前有了解过嵌体，感觉上要比烤瓷牙的磨损更少，硬度也相差不大，于是问了医生是否可以做嵌体，之后医生说嵌体一般是3楼牙体牙髓科室做的，让我去哪里问一下。我又去了三楼挂了黄医生的号……经过漫长的等待（2h左右），黄医生接诊了我，在简单的查看后，建议由于缺损较大， 嵌体无法修复，可以做cadcam全冠修复（使用cadcam技术相比普通全瓷牙要廉价1000左右。cadcam全瓷冠修复是3.7k，全瓷牙是4.5k）。医生把我的牙齿磨掉了一圈，然后下午去精密科室（好像是这个）拍照做全瓷牙冠。待到下午2点，直接去了精密科室，医生用一个小模型采集器（摄像头）对16牙齿周围拍照扫描建模，如图所示。<br><img src="https://user-images.githubusercontent.com/6647857/53867849-a9ec7f80-402f-11e9-9e73-c1ff254bdad9.jpg" alt="img_20190306_141239"></p><p><img src="https://user-images.githubusercontent.com/6647857/53876992-fbead080-4042-11e9-833a-6245ed9710fc.jpg" alt="tim 20190306190540"></p><p>很快就做好了大概一个小时，3.30之后医生就来叫我，把牙冠用胶水黏上之后再打磨一下就好了。<br>说一下结论把，这个cadcam全冠的优点：1，普通全瓷牙冠一般都是要一周才能做好带上。2，价格上比全瓷牙冠少了1k。<br>使用感受良好，至于能用多久就不清楚了。<br><img src="https://user-images.githubusercontent.com/6647857/53868380-e66cab00-4030-11e9-94a0-dd19b2252e4f.jpg" alt="1551861781687"><br><code>一张注意事项图</code></p><p>ref:</p><p>许琼莉, et al. <em>CEREC AC 及 MC XL 椅旁 CAD/CAM 全瓷修复的护理配合</em>. Diss. 2013.</p></blockquote><blockquote><p>另外，关于下颌骨，目前已经有所好转（不过看牙齿的时候张口那么久还是有一些难受，都麻木了），还没有打透明质酸针。觉得真的心态还是很重要，保持乐观就解决了一大半的病因。</p></blockquote><h4 id="2019-05-20-种植牙手术二期。"><a href="#2019-05-20-种植牙手术二期。" class="headerlink" title="2019.05.20 种植牙手术二期。"></a>2019.05.20 种植牙手术二期。</h4><blockquote><p>这次手术很简单，不过依旧是去内部的消毒手术室，打了点麻药，把内部的种植体露出来，然后将基台放入种植体上，预计再过十天之后去取牙模，做牙冠。</p></blockquote><h4 id="2019-05-23-45牙齿的牙冠"><a href="#2019-05-23-45牙齿的牙冠" class="headerlink" title="2019.05.23 45牙齿的牙冠"></a>2019.05.23 45牙齿的牙冠</h4><blockquote><p>今天早晨醒来发现45牙齿竟然裂了一条缝隙，于是急忙去医院看了一下，找了黄冰冰医生，下午拍摄了CAD影像以及将牙齿磨成圆形。第二天去将做好的牙冠装好。整个过程都比较顺利，牙冠装上之后和别的牙齿看起来没有异样，就是相对别的牙齿感觉要更为光滑一点。</p><p><img src="https://www.zkeenly.com/images/2019-05-28/1.jpg" alt="1551861781687"></p></blockquote><h4 id="2019-05-30-种植牙取模型"><a href="#2019-05-30-种植牙取模型" class="headerlink" title="2019.05.30 种植牙取模型"></a>2019.05.30 种植牙取模型</h4><blockquote><pre><code>由于种植牙无法采用倚旁cad的方式进行制作牙冠,所以采用了传统的通过取模型制作牙冠的方法.</code></pre><p>取模型的时候使用橡皮泥一样的物质在牙齿上压制形成模型,后续将模型送至工厂进行制备牙冠.原本以为制备牙冠只需要一周就可以解决,最后被告知需要40day才可以制作完成牙冠.无奈只能等待到7月中旬(然而七月中旬我将离开武汉去往广州工作),大约花费1k.</p></blockquote><h4 id="2019-09-12-种植牙牙冠修复"><a href="#2019-09-12-种植牙牙冠修复" class="headerlink" title="2019.09.12 种植牙牙冠修复"></a>2019.09.12 种植牙牙冠修复</h4><blockquote><pre><code>由于新就职期间请假不太方便,且当时牙冠安装需要周二-周四才可以安装.所以一直等到了九月份才有时间来安装牙冠.</code></pre></blockquote><p><img src="https://user-images.githubusercontent.com/6647857/64935064-5336ec80-d881-11e9-9b3f-5bcde967e0de.png" alt="image"></p><blockquote><p>牙冠以及如图所示,整个过程比较顺利,没有太多的不适感,牙冠不是通过胶水黏贴的,而是嵌入到基台内部的.牙冠的体积相对于对面的16来说小了很多,这很大程度是由于长期没有修复牙齿而导致牙齿间隙变小,且26与27牙齿之间不是很平整,感觉会有异样,但是饮食无碍,塞牙问题不大.</p></blockquote><h4 id="种植牙消费总计"><a href="#种植牙消费总计" class="headerlink" title="种植牙消费总计"></a>种植牙消费总计</h4><blockquote><p>共计消费 11288.7 ,比预计的花费要少一些.</p><blockquote><p>首次挂号费 16.5<br>种植牙手术 8407.4<br>两次复诊CT 126.5 126.5<br>牙冠制作 1146.5<br>牙冠安装 1465.3<br>详细账单下载:<br><a href="https://github.com/zkeenly/articles/files/3614790/default.zip" target="_blank" rel="noopener">武汉大学口腔医院种植牙账单.zip</a></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂事 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mnist识别研究-基于Keras的深度学习基础实例</title>
      <link href="/2018/11/10/Mnist%E8%AF%86%E5%88%AB%E7%A0%94%E7%A9%B6-%E5%9F%BA%E4%BA%8EKeras%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%AE%9E%E4%BE%8B/"/>
      <url>/2018/11/10/Mnist%E8%AF%86%E5%88%AB%E7%A0%94%E7%A9%B6-%E5%9F%BA%E4%BA%8EKeras%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="作业任务1：熟悉CNN与DNN（训练样本60000，测试10000）"><a href="#作业任务1：熟悉CNN与DNN（训练样本60000，测试10000）" class="headerlink" title="作业任务1：熟悉CNN与DNN（训练样本60000，测试10000）"></a>作业任务1：熟悉CNN与DNN（训练样本60000，测试10000）</h2><h3 id="利用CNN和DNN完成Mnist识别任务，CNN结构如下所示，DNN结构自定，将效果作为baseline。"><a href="#利用CNN和DNN完成Mnist识别任务，CNN结构如下所示，DNN结构自定，将效果作为baseline。" class="headerlink" title="利用CNN和DNN完成Mnist识别任务，CNN结构如下所示，DNN结构自定，将效果作为baseline。"></a>利用CNN和DNN完成Mnist识别任务，CNN结构如下所示，DNN结构自定，将效果作为baseline。</h3><h4 id="使用DNN，结构"><a href="#使用DNN，结构" class="headerlink" title="使用DNN，结构"></a>使用DNN，结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dense(32, input_dim=784),  # 全连接层。32个神经元，输入维度为784（28*28）</span><br><span class="line">Activation(&apos;relu&apos;),  # 激活层</span><br><span class="line">Dense(10),  # 全连接层，10个神经元</span><br><span class="line">Activation(&apos;softmax&apos;)  # 激活层</span><br><span class="line">nb_epoch=1, batch_size=32</span><br><span class="line">model.fit(X_train, y_train, nb_epoch=1, batch_size=32)</span><br></pre></td></tr></table></figure><p>两次效果：</p><blockquote><p>test loss: 0.21429610718488692<br>test accuracy:  0.9395<br>test loss: 0.21414068414568901<br>test accuracy:  0.9399</p></blockquote><h4 id="使用CNN结构"><a href="#使用CNN结构" class="headerlink" title="使用CNN结构"></a>使用CNN结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">conv_1 = Conv2D(32, kernel_size=(3, 3), activation=&apos;relu&apos;, input_shape=input_shape)</span><br><span class="line">conv_2 = Conv2D(64, (3, 3), activation=&apos;relu&apos;)</span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(conv_1)</span><br><span class="line">model.add(conv_2)</span><br><span class="line">model.add(MaxPooling2D(pool_size=(2, 2)))</span><br><span class="line">model.add(Dropout(0.25))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(128, activation=&apos;relu&apos;))</span><br><span class="line">model.add(Dropout(0.5))</span><br><span class="line">model.add(Dense(num_classes, activation=&apos;softmax&apos;))</span><br><span class="line">batch_size = 128</span><br><span class="line">num_classes = 10</span><br><span class="line">epochs = 1</span><br><span class="line">model.fit(x_train, y_train,</span><br><span class="line">          batch_size=batch_size,</span><br><span class="line">          epochs=epochs,</span><br><span class="line">          verbose=1, validation_data=(x_test, y_test))</span><br></pre></td></tr></table></figure><p>两次效果：</p><blockquote><p>Test loss: 0.06023046794650145<br>Test accuracy: 0.9816<br>Test loss: 0.06867549542314373<br>Test accuracy: 0.9775</p></blockquote><blockquote><p>结论：在同样的epoch下，cnn效果更好，时间更长。Dnn只要10s CNN需要5min</p></blockquote><h3 id="显示CNN的第一层（卷积层），第二层（激励层）的输出图片-输出其中9张"><a href="#显示CNN的第一层（卷积层），第二层（激励层）的输出图片-输出其中9张" class="headerlink" title="显示CNN的第一层（卷积层），第二层（激励层）的输出图片(输出其中9张)"></a>显示CNN的第一层（卷积层），第二层（激励层）的输出图片(输出其中9张)</h3><center><img src="https://user-images.githubusercontent.com/6647857/49086245-06047280-f28f-11e8-9d63-baa68a93f83b.png" alt="image"></center><br><center><img src="https://user-images.githubusercontent.com/6647857/49086254-0bfa5380-f28f-11e8-8ac0-f4f1e0b4c1fa.png" alt="image"></center><h3 id="Mnist中的每个图片做subsampling（研究两种方式，随机采样和抛弃一半），分别利用CNN和DNN在新样本集合作训练，考察subsampling对实验效果的影响（训练误差，测试误差，训练速度），考虑如何减小subsampling的影响。"><a href="#Mnist中的每个图片做subsampling（研究两种方式，随机采样和抛弃一半），分别利用CNN和DNN在新样本集合作训练，考察subsampling对实验效果的影响（训练误差，测试误差，训练速度），考虑如何减小subsampling的影响。" class="headerlink" title="Mnist中的每个图片做subsampling（研究两种方式，随机采样和抛弃一半），分别利用CNN和DNN在新样本集合作训练，考察subsampling对实验效果的影响（训练误差，测试误差，训练速度），考虑如何减小subsampling的影响。"></a>Mnist中的每个图片做subsampling（研究两种方式，随机采样和抛弃一半），分别利用CNN和DNN在新样本集合作训练，考察subsampling对实验效果的影响（训练误差，测试误差，训练速度），考虑如何减小subsampling的影响。</h3><h4 id="四倍降采样之后的结果："><a href="#四倍降采样之后的结果：" class="headerlink" title="四倍降采样之后的结果："></a>四倍降采样之后的结果：</h4><center><img src="https://user-images.githubusercontent.com/6647857/49086263-1583bb80-f28f-11e8-967a-e7845810f87c.png" alt="image"></center><blockquote><p>CNN：<br>运行时间：从5min变为为50s。<br>两次效果：<br>Test loss: 0.08262749407133088<br>Test accuracy: 0.9757<br>Test loss: 0.07995445217452943<br>Test accuracy: 0.9744<br>结论：测试误差不大。<br>DNN:<br>训练时间约为5s<br>test loss: 0.2969126805961132<br>test accuracy:  0.9169<br>结论：误差相对仍较大。</p></blockquote><h4 id="设置抛弃一半之后的效果："><a href="#设置抛弃一半之后的效果：" class="headerlink" title="设置抛弃一半之后的效果："></a>设置抛弃一半之后的效果：</h4><center><img src="https://user-images.githubusercontent.com/6647857/49086300-2a604f00-f28f-11e8-9a40-23b69cdd3daa.png" alt="image"></center><blockquote><p>CNN:<br>运行时间在2min左右。<br>两次测试效果：<br>Test loss: 0.19521159455776216<br>Test accuracy: 0.9417<br>Test loss: 0.1949758700400591<br>Test accuracy: 0.9389<br>结论：测试误差进一步增大，但是仍保持较高的准确率。<br>DNN：<br>训练时间约为5s<br>test loss: 0.39655784153938295<br>test accuracy:  0.8881<br>结论：误差相对CNN更大。</p></blockquote><h4 id="取原训练集前10-的样本做训练，测试集不变，考察CNN和DNN效果，考虑如何减小小样本集的影响。"><a href="#取原训练集前10-的样本做训练，测试集不变，考察CNN和DNN效果，考虑如何减小小样本集的影响。" class="headerlink" title="取原训练集前10%的样本做训练，测试集不变，考察CNN和DNN效果，考虑如何减小小样本集的影响。"></a>取原训练集前10%的样本做训练，测试集不变，考察CNN和DNN效果，考虑如何减小小样本集的影响。</h4><blockquote><p>CNN：<br>两次运行结果：<br>Test loss: 0.29531892013549804<br>Test accuracy: 0.9097<br>Test loss: 0.3230072082400322<br>Test accuracy: 0.9173<br>DNN：<br>两次运行结果：<br>test loss: 0.4636564645767212<br>test accuracy:  0.8762<br>test loss: 0.46389272186756136<br>test accuracy:  0.8767<br>通过调整nb_epoch=10，增加训练次数可优化测试结果：<br>test loss: 0.27507588347643613<br>test accuracy:  0.9222<br>继续增大epoch 将对结果影响不大（修改nb_epoch=100）：<br>test loss: 0.62979790314195<br>test accuracy:  0.9262</p></blockquote><h4 id="尝试对DNN增加池化层和Dropout层，考察DNN效果变化。"><a href="#尝试对DNN增加池化层和Dropout层，考察DNN效果变化。" class="headerlink" title="尝试对DNN增加池化层和Dropout层，考察DNN效果变化。"></a>尝试对DNN增加池化层和Dropout层，考察DNN效果变化。</h4><blockquote><p>无pooling层可对DNN池化（维度不一致）。<br>添加dropout(0.55):<br>test loss: 0.3060034876406193<br>test accuracy:  0.9186<br>添加dropout(0.80):<br>test loss: 0.5026416866779327<br>test accuracy:  0.8948<br>添加dropout(0.99):<br>test loss: 2.2277009323120116<br>test accuracy:  0.2207<br>结论：保持一定比例的dropout不会对结果产生太大影响，速度会有所提升。但是接近1时，将无法识别数据。</p></blockquote><h4 id="对kernel-size进行调整（一起调整，或者逐层调整），考察CNN效果变化。思考如何选择kernel-size"><a href="#对kernel-size进行调整（一起调整，或者逐层调整），考察CNN效果变化。思考如何选择kernel-size" class="headerlink" title="对kernel_size进行调整（一起调整，或者逐层调整），考察CNN效果变化。思考如何选择kernel_size"></a>对kernel_size进行调整（一起调整，或者逐层调整），考察CNN效果变化。思考如何选择kernel_size</h4><blockquote><p>修改kernel_size =conv1 (5,5),conv2(3,3):<br>Test loss: 0.04961018333421089<br>Test accuracy: 0.9844<br>结论：影响不大。准确率略有提高。<br>修改kernel_size=conv1(2,2),conv2(8,8):<br>Test loss: 0.04970626147154253<br>Test accuracy: 0.9824<br>结论：时间消耗为15min，效果无显著提升。可适当提升第一层卷积核，有助于提高识别率。</p></blockquote><h2 id="作业任务2：研究如何“欺骗”DNN和CNN"><a href="#作业任务2：研究如何“欺骗”DNN和CNN" class="headerlink" title="作业任务2：研究如何“欺骗”DNN和CNN"></a>作业任务2：研究如何“欺骗”DNN和CNN</h2><h3 id="输出DNN和CNN认为最像“8”的图片"><a href="#输出DNN和CNN认为最像“8”的图片" class="headerlink" title="输出DNN和CNN认为最像“8”的图片"></a>输出DNN和CNN认为最像“8”的图片</h3><blockquote><p>DNN（most likely eight）：<br>可能性: 0.9992219位置 5003</p></blockquote> <center><img src="https://user-images.githubusercontent.com/6647857/49086325-3ba95b80-f28f-11e8-8f3d-2d74a293b0ce.png" alt="image"></center><blockquote><p>CNN（most likely eight）:<br>可能性: 0.99999833位置 7114</p></blockquote> <center><img src="https://user-images.githubusercontent.com/6647857/49086353-49f77780-f28f-11e8-8c57-3863ae06fcff.png" alt="image"></center><h3 id="在真实“8”图片上加入噪声，让DNN与CNN认为它是“9”"><a href="#在真实“8”图片上加入噪声，让DNN与CNN认为它是“9”" class="headerlink" title="在真实“8”图片上加入噪声，让DNN与CNN认为它是“9”"></a>在真实“8”图片上加入噪声，让DNN与CNN认为它是“9”</h3><blockquote><p>DNN fake9:</p></blockquote><center><img src="https://user-images.githubusercontent.com/6647857/49086372-54b20c80-f28f-11e8-9ae0-4ec6a5aef3f2.png" alt="image"></center><blockquote><p>预测值的概率：<br>[[4.0106301e-07 1.8723180e-05 2.6028445e-05 4.2457259e-04 2.4138275e-04 2.7176596e-03 1.5008907e-06 3.7194110e-02 4.5580325e-01 5.0357234e-01]]<br>最可能的值： 9<br>CNN fake9:</p></blockquote> <center><img src="https://user-images.githubusercontent.com/6647857/49086392-5e3b7480-f28f-11e8-9dd6-97bc7dd920d3.png" alt="image"></center><blockquote><p>预测值的概率:<br> [[0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]]<br>最可能的值：<br>结论：若使用DNN的fake9样例，仍可识别为8</p></blockquote> <center><img src="https://user-images.githubusercontent.com/6647857/49086412-698ea000-f28f-11e8-971e-ccfc984ae287.png" alt="image"></center><blockquote><p>预测值的概率:<br>[[0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]]<br>最可能的值： 8</p></blockquote><p>code：<a href="https://github.com/zkeenly/mnist_base_dl" target="_blank" rel="noopener">点击这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mnist </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Faster-Rcnn翻译+详解</title>
      <link href="/2018/10/19/Faster-Rcnn%E7%BF%BB%E8%AF%91-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/19/Faster-Rcnn%E7%BF%BB%E8%AF%91-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster RCNN"></a>Faster RCNN</h2><p>我们将本文的目标检测系统称之为Faster Rcnn。其中包含两个部分，第一部分是深度全卷积网络模型来提取候选区域，第二个是Fast Rcnn识别模型。整个系统是统一的目标识别网络。如图所示，我们采用最近流行的术语“注意力”机制，使用RPN模型用来指引Fast Rcnn模型应该“看”哪里。在3.1中我们将介绍RPN网络的详细设计。在3.2中我们将设计算法使用特征共享的方式对两个模型训练。</p><p><img src="https://www.zkeenly.com/images/2019-03-19/1552960089165.png" alt="1552960089165"></p><h3 id="3-1-区域选择网络（RPN）"><a href="#3-1-区域选择网络（RPN）" class="headerlink" title="3.1 区域选择网络（RPN）"></a>3.1 区域选择网络（RPN）</h3><p>​    RPN采用任意大小的图像作为输入，输出一个目标矩阵框集合，每一个目标矩阵都包含对象的分数。我们采用全卷积网络完成处理，在这一章将详细描述。由于我们最终需要与Fast Rcnn 对比，我们采取与fast rcnn 使用一样的卷积层。我们采用ZF和VGG16测试。ZF包含5个可共享的卷积层，VGG16包含12个可共享的卷积层。</p><p>​    为了生成区域选择框，我们采用一个小的网络在最后输出的卷积特征图上滑动，这个小网络采用3*3的卷积层滑动。每一个滑动窗口都映射到题为特征中（ZF的256d，VGG16的512d，之后跟随Relu）。这个特征传送到两个同级全连接层（box-regression layer 以及 box-classification layer）。这个小网络如图3所示（左侧），</p><p><img src="https://www.zkeenly.com/images/2019-03-19/1552960114278.png" alt="1552960114278"></p><h4 id="3-1-1-Anchors"><a href="#3-1-1-Anchors" class="headerlink" title="3.1.1 Anchors"></a>3.1.1 Anchors</h4><p>在每一个滑动窗口的位置，我们同时预测多个区域候选，每个位置最多包含K个anchor boxes（通过每个位置扩展出不同形状的候选框），然后cls包含2k个输出结果，用来估计每个候选框是不是可能的目标对象。reg包含4k个输出结果用来保存每个候选框的坐标位置。ancher在滑动窗口的中心位置，并且由三个放大率和三个方向调节，每个滑动窗口中心点会生成9个ancher，这个输出的卷积特征图中一共输出大概2400个候选区域（每个候选区域都由两个scores 和四个coordinates）。</p><h5 id="平移不变Anchors"><a href="#平移不变Anchors" class="headerlink" title="平移不变Anchors"></a>平移不变Anchors</h5><p>我们的方法一个最重要的属性是平移不变性，我们的方法保证了关于anchors 和计算相关区域到anchors的函数的平移不变性。平移不变性由全卷积网络的性质得到。相对的，在MultiBox方法中，使用k-means产生800个anchors ，是没有办法保证平移不变性的，所以MultiBox无法保证相同的区域在经过并以变换后仍然可以识别。</p><blockquote><p> 大概是说，卷积网络相对k-means更容易保持平移不变性</p></blockquote><p>平移不变性同时降低了模型的大小，MultiBox由（4+1）<em> 800维度全连接输出层，然而我们的方法仅有（4+2）</em> 9维度的卷积输出层，在k=9anchors的时候。我们的输出层包含2.9 <em> 10^4个参数（VGG16的512</em> （4+2）<em> 9），而MultiBox‘s的输出包含6.1</em> 10^6参数（googlenet1536<em> （4+ 1）</em>  800）。如果考虑后面特征映射层，我们的方法相对MultiBox会少多个量级的参数，同时我们认为我们的方法将会具有更小的过拟合风险。</p><h5 id="Multi-Scale-Anchors-as-Regression-References"><a href="#Multi-Scale-Anchors-as-Regression-References" class="headerlink" title="Multi-Scale Anchors as Regression References"></a>Multi-Scale Anchors as Regression References</h5><p>我们设计一个新的anchors的多尺度提取方法（多方向比例），如图所示，目前由两个主流的方法来进行多尺度预测。第一种方法是基于图像/特征金字塔（DPM，CNN方法）。图像将多尺度统一大小，然后经过特征提取（HOG,深度卷积），分别计算每一个尺度。这种方式往往时间开销很大。第二种方法是通过使用多适度的滑动窗口，不同尺度使用不同的滤波大小来训练（例如5<em> 7，7</em> 5）。如果使用这种方法解决多尺度问题，这可以称为滤波金字塔模型。通常两种方法联合采用。</p><p><img src="https://www.zkeenly.com/images/2019-03-19/1552960150332.png" alt="1552960150332"></p><p>​    相应的，我们的anchor是用过建立一个更高效的“anchor金字塔”方法。我们的分类和多尺度回归边框的方法仅仅依赖于但尺度的图像和特征度，并且使用单尺度的滤波。我们采用这种有效地措施来解决多尺度和大小问题，由表中可以看出。</p><p>​    由于多尺度设计是基于anchors 的，我们可以完全使用卷积层来计算单尺度图像。这个多尺度anchors是一个解决多尺度问题而不增加更多开销的关键部分。</p><h4 id="3-1-2-损失函数"><a href="#3-1-2-损失函数" class="headerlink" title="3.1.2 损失函数"></a>3.1.2 损失函数</h4><p>为了训练RPN，我们为每一个anchor赋值二分类标签。我们赋值正样本标签给两种anchors：1，这个anchor/cnchors 是一个最高的intersection-over-union（iou），基准box重叠率。2，一个anchor的重叠率高于0.7其他基准box。每个基准box可能会赋值给多个anchors正标签。通常第二种是足够决定正样本了；但是我们仍然采用第一种情况，由于在少量情况第二种也许不能找到正样本。如果Iou率是少于0.3的，我们为所有基准box的非正anchor赋值负标签。如果anchors 不是正的也不是负的，那对训练目标没有帮助。</p><p>我们在训练Fast Rcnn最小化目标函数通过多任务损失函数。我们图像的损失函数定义为：</p><p><img src="https://www.zkeenly.com/images/2019-03-19/1552960224187.png" alt="1552960224187"></p><ul><li>i 是这个anchor在mini-batch 的索引，</li><li>p<sub>i</sub>是anchor i 是一个目标的概率。</li><li>如果anchor是正样本，基准标签p<sub>i</sub><sup>* </sup>是1。负样本则是0。</li><li>t<sub>i</sub>是一个向量，代表4个坐标的参数。来预测bounding box。</li><li>t<sub>i</sub><sup> * </sup> 是相应的基准正样本标签。</li><li>类别损失L<sub>cls</sub> 是两个类别的log损失函数。</li><li>回归损失我们使用L<sub>reg</sub> (t<sub>i</sub>, t<sub>i</sub> <sup><em> </em></sup> ) = R(t<sub>i</sub> -  t<sub>i</sub><sup>   </sup>  )</li><li>R是[2] 中定义的robust损失函数（smooth L<sub>1</sub>）。</li><li>p<sub>i</sub> <sup><em> </em></sup> L<sub>reg</sub> 意味着回归损失仅仅当正样本（p<sub>i</sub> <sup> </sup> =1）的时候被激活，放负样本（p<sub>i</sub> <sup>* </sup> =0）的时候激活。</li><li>输出层cls 和reg 分别包含{p<sub>i</sub> }和{t<sub>i</sub>}。</li></ul><p>这两部分由N<sub>cls</sub> 和N<sub>reg</sub> 以及平衡参数的权重 \lambda 标准化。在我们当前的实现方法中，cls列表在公式（1）中是被mini-batch size标准化的。reg 由anchor 位置的数量标准化的。我们默认设置 \lambda =10，并且使cls 和reg 具有大概相等的权重。我们通过实现设置不同的lambda 值得到不同的结果。所以标准化是不需要过于强调，而应该尽量简化。</p><p><img src="https://www.zkeenly.com/images/2019-03-19/1552987177356.png" alt="1552987177356"></p><p>​    对于边框回归，我们采用四个坐标的参数化:</p><p><img src="https://www.zkeenly.com/images/2019-03-19/1552987990659.png" alt="1552987990659"></p><p>其中，x,y,w以及h决定这个box的中心坐标以及宽和高。变量 x, x<sub>a</sub> ,以及x<sup>* </sup> 分别是预测box， anchorbox，以及基准box。这样可以使anchor box 通过bounding-box回归到附近的基准box。</p><p>​    此外，我们的方法bounding-box 回归方法不同于其他Roi等方法，bounding-box 回归可以得到任意的Roi大小，回归权重可以与所有大小的范围共享。在我们的公式中，用于回归的特征提取在特征图上使用了相同的卷积大小（3* 3）。为了得到不同的大小，我们设置学习k个回归框。每一个回归是代表一个尺度和方向改变率，并且k回归不能共享权重。同样的，得益于anchors 的设计，它也是可以通过修复尺度和大小来预测不同大小的。</p><h3 id="3-1-3-训练-RPNS"><a href="#3-1-3-训练-RPNS" class="headerlink" title="3.1.3 训练 RPNS"></a>3.1.3 训练 RPNS</h3><p>​    RPN可以通过反向传播以及梯度下降训练端到端网络。我们“image-centric”策略来训练网络。每次从单一图像包含正负样例的anchors mini-batch 。为所有anchor损失函数优化是可能的，但是这将会偏向于负样本，因为负样本是多数的。相反，我们随机256个anchors 样本在图像中计算mini-batch损失函数，在这里正负样本比例为1：1。如果少于128个正样本，那么我们使用负样本填充mini-batch。</p><p>​    我们通过高斯标准分布0.01，随机初始化所有层的权重。其他（共享权重的）使用预处理模型初始化来作为标准。我们使用学习率为0.001 在60K个minibatchs上，学习率为0.0001在生于20K个mini-batchs上，我们采用动量优化参数为0.9，权重衰退为0.0005，采用caffe实现。</p><h2 id="3-2-RPN与Fast-Rcnn的特征共享"><a href="#3-2-RPN与Fast-Rcnn的特征共享" class="headerlink" title="3.2 RPN与Fast Rcnn的特征共享"></a>3.2 RPN与Fast Rcnn的特征共享</h2><p>现在，我们将要描述如何训练区域范围生成网络，不考虑利用这些范围的基于区域的目标识别CNN。对于检测网络，我们采用 Fast Rcnn。接下来我们描述将RPN和FastRcnn一体化的算法，并且共享卷积层，如图2.</p><p>将RPN和Fast Rcnn 训练单独训练将会以不同的方式修改卷积层。我们因此需要一种技术来允许共享共享两个网络的卷积层。我们以三种特征共享的方式训练网络：</p><p>（i）Alternating training，这种解决方法，我们首先训练RPN，并且使用目标区域来训练 Fast Rcnn，这个网络通过Fast Rcnn 来微调经过初始化过的RPN，并且这个方法是可迭代的。这是在本文所有实验中采用的一种方法。</p><p>（ii）Approximate joint training（近似联合训练）. 这种方法，RPN和Fast Rcnn 网络被融合在一个网络中，像图2中训练的。在每次SGD迭代中，正向传播中的区域生成参数被固定，当训练Fast Rcnn检测器的时候预先计算区域建议框。反向传播和往常相同，共享层的反向传播信号中RPN和Fast Rcnn的loss相结合。这个方案是容易实现的。但是这个方法忽视了衍生的候选盒子坐标 w.r.t.，这个坐标也是网络的回应，所以是近似的。在我们的实验中，我们的经验中发现这个解决方案产生了相近的结果，但是降低了25%的计算时间。这个方案在哦我们提供的Python 代码中。</p><p>（iii）Non-approximate joint training. 根据以上讨论，这个通过RPN的边框预测也是一个输入函数。在Fast Rcnn的RoI 池化层 接受这个卷积特征并且预测边框作为一个输入，因此，一个理论上有效的反向传播求解器也应该包含梯度w.r.t。上述近似联合训练忽略了这些梯度。在非近似联合训练解中，我们需要一个RoI池层，它是可导的w.r.t.坐标。这是一个非常重要的问题，可以通过[15]中开发的“RoI池化”层给出解决方案，这超出了本文的讨论范围。</p><p><strong>四步交替训练</strong> 。在这个文中，我们采用实用的四步训练算法来通过交替优化学习共享特征。在第一步，我们如3.1.3训练RPN。这个网络由ImageNet 预训练模型初始化，并且微调这个端到端的区域选择任务。在第二步骤，我们通过Fast Rcnn使用第一步骤区域生成的RPN，训练一个可分离的检测网络。这个检测网络也有ImageNet预训练模型来训练。在这一点，两个网络不能够共享卷积层。第三步骤，我们使用检测网络初始化RPN训练模型，然后固定共享的卷积层，并且只微调RPN层。现在这两个网络共享了卷积层。最终保持这个共享卷积层固定，然后微调FastRcnn的网络层。如此，两个网络合并为统一网络并共享相同的卷积层。一个相似的交替训练方法可以运行多次，但是我们看到之后的改善并不明显。</p><h2 id="3-3-实现细节"><a href="#3-3-实现细节" class="headerlink" title="3.3 实现细节"></a>3.3 实现细节</h2><p>我们训练和测试 单尺度图像上的区域选择和对象检测网络[1] [2]。我们统一调整尺寸为短边600 像素[2]。多尺度特征提取（使用image pyramid）也许会改善精度但是不能有一个好的速度以及准确速度的权衡[2]。在重新调整图像尺度，在最后一个卷积层上，ZF 和VGG网络总步幅都是16像素。并且因此，在调整大小之前，典型的pascal网络具有大概10个像素。尽管如此，大尺度的步幅仍会有一个好的结果，尽管小的尺度可能会有更好的精度。</p><p>对于anchors，我们采用3个尺度，128<sup>2</sup> ,256<sup>2</sup> , 512<sup>2</sup> 。以及三个方向调整 1：1，1：2，2：1.这些这些超参数没有根据特别的数据集进行选择，我们下一章有具体实验结果。在我们的讨论中，我们的方法不需要图像金字塔或者滤波器金字塔来预测多个尺度的区域，从而节省了运行时间。图3右侧显示了我们对于多个尺度的预测效果。表1显示了学习到的每一个anchor平均区域大小。我们的算法允许比潜在感知区域更大范围的预测。这样的预测并不是不可能的-如果一个物体的中心是可见的，那么可以大概的估计出物体的范围。</p><p><img src="https://www.zkeenly.com/images/2019-03-19/1553472595147.png" alt="1553472595147"></p><p>穿过图像边界的anchor boxes需要谨慎处理，在训练的时候，我们忽视所有越过边界的anchors，它们对loss没有帮助。对于典型的1000<em> 600图像，一共大概会有20000个（60</em> 40 * 9）个anchor 。随着边界anchors被忽略，大概每张图片一共有6000个anchors用于训练，如果这个越过边界的anchors 不被忽略，则会在目标函数中引入大的，难以纠正的误差项，且训练不会收敛。但在测试过程中，我们仍然将全卷积RPN应用于整张图像。这可能会产生跨边界的提议边界框，我们剪切到图像边界。</p><p>​    一些RPN提议互相之间高度重叠。为了减少冗余，我们在提议区域根据他们的<em>cls</em>分数采取非极大值抑制（NMS）。我们将NMS的IoU阈值固定为0.7，这就给每张图像留下了大约2000个提议区域。正如我们将要展示的那样，NMS不会损害最终的检测准确性，但会大大减少提议的数量。在NMS之后，我们使用前N个提议区域来进行检测。接下来，我们使用2000个RPN提议对Fast R-CNN进行训练，但在测试时评估不同数量的提议。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的说，整个流程为</p><p><img src="https://www.zkeenly.com/images/2019-03-19/1553479914604.png" alt="1553479914604"></p><p>input-特征提取-RPN生成候选区域-RoI统一大小-Fast Rcnn预测目标分类</p><ol><li><p>假设原图为720<em>1280，resize为600 </em> 1067</p></li><li><p>input图像经过conv5_3 特征提取生成1 <em> 38 </em> 67 * 1024。的特征图。</p></li><li><p>将38 * 67 的特征图传送到RPN中，进行预测是前景还是背景。</p><ol><li>RPN网络具体为采用3<em> 3的滤波器以stride=1 滑动特征图。每次滑动为一个anchor，然后这个anchor扩展为9个不同方向和大小的anchor。一共得到38 </em> 67 * 9个原始图片proposal。</li><li>将剔除越过边界的anchor后剩余部分的anchor 进行预测是前景还是背景，输出cls_score（分类参数），以及bbox_pred（坐标参数）。</li><li>将得到的结果进行非极大抑制，大概留下2000个框作为RPN。</li></ol></li><li>将2000个RPN与特征图相结合，进行RoI Pooling，得到固定尺寸的特征图。送至Fast Rcnn中进行预测。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[数据结构]双散列Doublehashing常用方法</title>
      <link href="/2016/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E6%95%A3%E5%88%97doublehashing%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2016/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E6%95%A3%E5%88%97doublehashing%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://zkeenly.com/images/2016-07-13-1.png" alt="2016-07-13-1"></p><p><img src="https://zkeenly.com/images/2016-07-13-2.png" alt="2016-07-13-2"></p><p><img src="https://zkeenly.com/images/2016-07-13-3.png" alt="2016-07-13-3"></p><p><img src="https://zkeenly.com/images/2016-07-13-4.png" alt="2016-07-13-4"></p><p>[(X mod TableSize) +F(i)] mod TableSize</p><p>其中F(i) = i*hash2(X)</p><p>function F(i)    hash2(X) = R-(X mod R)  //R 可自己选择。此function也可自己定义。</p><p>参考文献；</p><p>[1] Weiss M A, 冯舜玺. 数据结构与算法分析——C 语言描述[J]. 2004.</p><p>[2] Weiss M A. Data Structures and Algorithm Analysis in C: For Anna University, 2/e[M]. Pearson Education India, 2002.</p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[ACM/算法]eoj2517辗转相除计算最小公倍数，公式法计算最大公约数</title>
      <link href="/2016/07/12/ACM-%E7%AE%97%E6%B3%95-eoj2517%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E8%AE%A1%E7%AE%97%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%EF%BC%8C%E5%85%AC%E5%BC%8F%E6%B3%95%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
      <url>/2016/07/12/ACM-%E7%AE%97%E6%B3%95-eoj2517%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E8%AE%A1%E7%AE%97%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%EF%BC%8C%E5%85%AC%E5%BC%8F%E6%B3%95%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n,a,b;</span><br><span class="line"> <span class="built_in">scanf</span>(“%d”,&amp;n);</span><br><span class="line"> <span class="keyword">while</span>(n–)&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(“%d %d”,&amp;a,&amp;b);</span><br><span class="line"> <span class="built_in">printf</span>(“%d %d\n”,GCD(a,b),a*b/GCD(a,b));</span><br><span class="line"> &#125;</span><br><span class="line"> system(“pause”);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">void</span></span><br><span class="line"> change(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)&#123;</span><br><span class="line"> <span class="keyword">int</span> temp;</span><br><span class="line"> temp = *a;</span><br><span class="line"> *a = *b;</span><br><span class="line"> *b = temp;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span></span><br><span class="line"> GCD(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line"> <span class="keyword">int</span> x;</span><br><span class="line"> <span class="keyword">while</span>(b)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line"> change(&amp;a, &amp;b); <span class="comment">//</span></span><br><span class="line"> &#125;</span><br><span class="line"> x = a % b;</span><br><span class="line"> a = b;</span><br><span class="line"> b = x;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br><span class="line"> 其中 a*</span><br></pre></td></tr></table></figure><p>b/GCD(a,b) 为计算最小公倍数的公式。</p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[数据结构]循环队列尾插法</title>
      <link href="/2016/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%B0%BE%E6%8F%92%E6%B3%95/"/>
      <url>/2016/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%B0%BE%E6%8F%92%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>数据结构教程1.9</p><p><img src="https://zkeenly.com/images/2016-07-03-1.png" alt="BaiduShurufa_2016-7-3_12-44-59"></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line"> en_queen(<span class="keyword">int</span> x)&#123;</span><br><span class="line"> tail = (tail+<span class="number">1</span>)%N;<span class="comment">//后移一位</span></span><br><span class="line"> <span class="keyword">if</span>(tail == head)&#123;</span><br><span class="line"> <span class="built_in">printf</span>(“out of queen\n”);</span><br><span class="line"> <span class="keyword">if</span>(tail == <span class="number">0</span>)&#123;</span><br><span class="line"> tail = N<span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> tail–;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> queen[tail<span class="number">-1</span>] = x;<span class="comment">//尾插法插入数据。</span></span><br><span class="line"> <span class="keyword">if</span>(head == <span class="number">-1</span>)&#123; <span class="comment">//将head置位</span></span><br><span class="line"> head = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(“enter queen success!\n”);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span></span><br><span class="line"> de_queen()&#123;</span><br><span class="line"> <span class="keyword">if</span>(head == tail || head == <span class="number">-1</span>)&#123;</span><br><span class="line"> <span class="built_in">printf</span>(“empty of queen!\n”);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(“<span class="built_in">exit</span> queen success:\n”);</span><br><span class="line"> head = (head+<span class="number">1</span>)%N;</span><br><span class="line"> <span class="keyword">return</span> queen[head<span class="number">-1</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>需要注意的几点：<br> 1、队列不能存满，head == tail || head == -1用来判断队列空的情况。如果队列存满，如下图所示：（tail指向即将插入的元素，队列满的话，tail 与head重合）<img src="https://zkeenly.com/images/2016-07-03-2.png" alt="BaiduShurufa_2016-7-3_13-20-11"></p><p>head == tail 也表示队列满，此时无法鉴别是队空还是队满。所以队列不能存满，每次先将tail+1，与head比较是否重合，如果重合，则不能再存储数据。如果不重合，则存储在原来的位置。<br> 2、 第一次进队列需要将初始化的head = -1 置为0。<br> 附：<br> <img src="https://zkeenly.com/images/2016-07-03-3.png" alt="BaiduShurufa_2016-7-3_13-15-0"></p><p>参考文献：</p><p>[1] 蔡子经. 施伯乐[J]. 数据结构教程, 1994.</p><p>[2]蔡子经. 施伯乐数据结构教程上海: 复旦大学出版社[J]. I999.</p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[数据结构]反转单链表中所有数据元素</title>
      <link href="/2016/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/"/>
      <url>/2016/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>数据结构教程1.12</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node *</span><br><span class="line">reverse1(Node *current)&#123;</span><br><span class="line">Node *previous;</span><br><span class="line">Node *next;</span><br><span class="line"><span class="keyword">for</span>(previous = <span class="literal">NULL</span>;current!=<span class="literal">NULL</span>;current = next)&#123;</span><br><span class="line">next = current-&gt;link; <span class="comment">//需要事先保存current -&gt;link ,后面有所改动。</span></span><br><span class="line">current-&gt;link = previous;</span><br><span class="line">previous = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pravious;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要交换指针方向即可。<br>定义next与previous<br>从思路上只需要改变指针的指向即可，第一个元素指向NULL，然后令previous为current，current为next继续改变下一个节点指针。</p><p>参考文献：</p><p>[1] 蔡子经. 施伯乐[J]. 数据结构教程, 1994.</p><p>[2]蔡子经. 施伯乐数据结构教程上海: 复旦大学出版社[J]. I999.</p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[ACM/算法]eoj1005分时操作系统</title>
      <link href="/2016/06/30/ACM-%E7%AE%97%E6%B3%95-eoj1005%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2016/06/30/ACM-%E7%AE%97%E6%B3%95-eoj1005%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>Description</strong> </p><p>ACM（Advanced Computer Machine）是一种新出的计算机硬件系统，它正面临上市，但是缺少一种操作系统来配合它独特的硬件。所以，公司决为它开发一种新的操作系统。在这个操 作系统中，所有的进程都用PID来表示，它是一个正整数，每个程序都有唯一的一个PID来区分。因为它是一个分时操作系统，所以每个程序都有一定的时间， 所以系统需要写一个程序执行的序列。你作为这个开发小组一员，将负责写一个程序来生成这个序列。<br>ACM的一条指令Register是双字节指令，用来注册一个程序的运行，格式是这样的:<br>Register PID TIME</p><p>PID是程序的PID号，TIME这个PID所对应的程序运行的时间间隔(单位为MS)。PID,TIME是正整数。</p><p>另一条指令是EndRegister，用来表示Register指令的结束。<br>最后是指令Run，格式如下：<br>Run NUM<br>NUM生成指令的长度。</p><p>例如:<br>Register 2004 200<br>Register 2005 300<br>EndRegister<br>Run 5</p><p>那么程序执行的序列是:<br>2004<br>2005<br>2004<br>2004<br>2005</p><p><strong>Input</strong> </p><p>第一行有一个正整数n，表示有几个测试数据。<br>每一个测试数据包含一组指令（Register,EndRegister,Run），对于每一组数据，0&lt;PID&lt;=2^16，0&lt; TIME&lt;=1000，0&lt;NUM&lt;=10000。你可以假定没有超过1000条的Register指令，并且只有一条 EndRegister和Run指令。<br>如果有几条指令同时发生，那么按他们的PID大小，从小到大的输出。</p><p><strong>Output</strong> </p><p>对于每一组测试数据，第一行输出是第几个数据”test case n:”，之后的NUM行输出生成的指令。两组数据之间空一行。</p><p><strong>Sample Input</strong> </p><p>2<br>Register 2004 200<br>Register 2005 300<br>EndRegister<br>Run 5<br>Register 2004 100<br>Register 2005 200<br>EndRegister<br>Run 6</p><p><strong>Sample Output</strong> </p><p>test case 1:<br>2004<br>2005<br>2004<br>2004<br>2005</p><p>test case 2:<br>2004<br>2004<br>2005<br>2004<br>2004<br>2005</p><p>思路上还是比较清楚的<br>1、建立结构体包括PID 和TIME<br>2、录入数据<br>3、控制数据输出</p><h4 id="在第二步骤时遇到一些小麻烦，其实本题只需要验证EndResigter就可以了。不需要管是不是输入的是Resigter"><a href="#在第二步骤时遇到一些小麻烦，其实本题只需要验证EndResigter就可以了。不需要管是不是输入的是Resigter" class="headerlink" title="在第二步骤时遇到一些小麻烦，其实本题只需要验证EndResigter就可以了。不需要管是不是输入的是Resigter"></a>在第二步骤时遇到一些小麻烦，其实本题只需要验证EndResigter就可以了。不需要管是不是输入的是Resigter</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;flag);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(flag,<span class="string">"EndRegister"</span>) ==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;temp[count].PID,&amp;temp[count].TIME);</span><br><span class="line">count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中直接用scanf是最直接有效的，起初还打算用sscanf或者gets()，发现错误越陷越深。</p><h4 id="第三步骤是重点"><a href="#第三步骤是重点" class="headerlink" title="第三步骤是重点"></a>第三步骤是重点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">last[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"test case %d:\n"</span>,N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;run; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;count;j++)&#123;   <span class="comment">//找到最小的执行时间点。</span></span><br><span class="line"><span class="keyword">if</span>(last[j]*temp[j].TIME &lt; min || last[j]*temp[j].TIME == min &amp;&amp;temp[j].PID &lt;temp[k].PID)&#123;</span><br><span class="line">min = last[j]*temp[j].TIME;</span><br><span class="line">k = j; <span class="comment">//j 之后自增;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">last[k]++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp[k].PID);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要用到last表记录每次运行一个进程是寻找最优进程的权值。就是说每次运行过一次进程之后last会自增。</p><p>last初始值为1，即该进程j开始下次运行总共所需时间间隔temp[j].TIME * last[j] 。 那么这个时间最小的进程就是即将可以运行的进程。</p><p>我们通过以下图表可以看到运行过程：</p><p><img src="https://zkeenly.com/images/2016-6-30-1.png" alt="BaiduShurufa_2016-6-30_19-1-12"></p><p>通过此图可以看到进程执行过程的时间其实是忽略不计的，主要时间消耗在时间间隔。并且每一个程序的时间间隔都是相互独立的，并没有互相影响。即计算机每运行200ms就可以有一次执行PID 2004的机会，每运行300ms就有一次执行PID 2005的机会。 只有当600ms时即可以执行PID 2004 又可以PID 2005的时候才会选择PID 较小的优先执行。</p><p>通过以上分析，我们建立last数据记录每一个进程执行次数，通过计算执行次数*每次执行所需的时间 可以得出次进程下一次执行会在那个时间点，那么只需要找到最小的一个执行时间点 ，执行此进程即可。</p><p>附源程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PROCESS</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> PID;</span><br><span class="line"><span class="keyword">int</span> TIME;</span><br><span class="line">&#125;PROCESS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">PROCESS temp[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">char</span> flag[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> run;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;flag);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(flag,<span class="string">"EndRegister"</span>) ==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;temp[count].PID,&amp;temp[count].TIME);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,&amp;flag,&amp;run);</span><br><span class="line"><span class="keyword">int</span> last[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">last[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"test case %d:\n"</span>,N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;run; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;count;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(last[j]*temp[j].TIME &lt; min || last[j]*temp[j].TIME == min &amp;&amp;temp[j].PID &lt;temp[k].PID)&#123;</span><br><span class="line">min = last[j]*temp[j].TIME;</span><br><span class="line">k = j; <span class="comment">//j 之后自增;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">last[k]++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp[k].PID);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">init(i);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[数据结构]线性时间打印L链表中p链表元素位置的元素</title>
      <link href="/2016/06/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%89%93%E5%8D%B0l%E9%93%BE%E8%A1%A8%E4%B8%ADp%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>/2016/06/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%89%93%E5%8D%B0l%E9%93%BE%E8%A1%A8%E4%B8%ADp%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线性时间打印序列L中P位置的元素"><a href="#线性时间打印序列L中P位置的元素" class="headerlink" title="线性时间打印序列L中P位置的元素"></a>线性时间打印序列L中P位置的元素</h1><p>P也是序列，采用方法为先将P位置序列排序，然后遍历L序列，设置计数器。</p><p>当计数器数字与P位置序列中元素相同，则打印L当前元素数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">PrintLots(List L,List P)&#123;</span><br><span class="line"><span class="comment">// lsort(L);</span></span><br><span class="line">lsort(P);</span><br><span class="line">Position N = P-&gt;Next;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(L-&gt;Next !=<span class="literal">NULL</span> &amp;&amp; P-&gt;Next !=<span class="literal">NULL</span>)&#123;<span class="comment">//线性解决方法</span></span><br><span class="line"><span class="keyword">if</span>(P-&gt;Next-&gt;Element == count++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(“%d”,L-&gt;Next-&gt;Element);</span><br><span class="line">P = P-&gt;Next;</span><br><span class="line">&#125;</span><br><span class="line">L = L-&gt;Next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// while(N !=NULL)&#123; //O（N^2）解决</span></span><br><span class="line"><span class="comment">// lprintnumber(L,N-&gt;Element);</span></span><br><span class="line"><span class="comment">// N = N-&gt;Next;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献：</p><p>[1] 蔡子经. 施伯乐[J]. 数据结构教程, 1994.</p><p>[2]蔡子经. 施伯乐数据结构教程上海: 复旦大学出版社[J]. I999.</p>]]></content>
      
      
      <categories>
          
          <category> ACM/算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C和指针习题6.2与6.3分析</title>
      <link href="/2016/02/05/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%986-2%E4%B8%8E6-3%E5%88%86%E6%9E%90/"/>
      <url>/2016/02/05/C%E5%92%8C%E6%8C%87%E9%92%88%E4%B9%A0%E9%A2%986-2%E4%B8%8E6-3%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.zkeenly.com/images/2016-02-05/20190327085508-1.jpg" alt=""></p><p><img src="https://www.zkeenly.com/images/2016-02-05/20190327085508-2.jpg" alt=""></p><p><img src="https://www.zkeenly.com/images/2016-02-05/20190327085508-3.jpg" alt=""></p><p><img src="https://www.zkeenly.com/images/2016-02-05/20190327085508-4.jpg" alt=""></p><p> <img src="http://img.blog.csdn.net/20160205191809974" alt="这里写图片描述"><br>我觉得内存模型大概是如此：<br><img src="http://img.blog.csdn.net/20160205191823364" alt="这里写图片描述"><br>如果改变<code>*strings++</code>那么指针将会指向第二行，如果使用 <code>*(*strings)</code>那么指针将会向后移动一列。<br>在find_char1函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    char *string;</span><br><span class="line">​    while((string  = *strings++)!=NULL)&#123; //将会改变令指针数组指向下一行？</span><br><span class="line">​        while(*string !=&apos;\0&apos;)&#123;</span><br><span class="line">​            printf(&quot;%c\n&quot;,*string);</span><br><span class="line">​            if(*string++ == value)</span><br><span class="line">​                return 1;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">在 find_char2函数中：</span><br><span class="line">​    while(strings!=NULL)&#123;</span><br><span class="line">​        while(**strings!=&apos;\0&apos;)&#123;</span><br><span class="line">​            printf(&quot;%c\n&quot;,*(*strings));</span><br><span class="line">​            if(*(*strings)++ == value)//将会改变指针数组指向后面一个数据？</span><br><span class="line">​                return 1;</span><br><span class="line">​        &#125;</span><br><span class="line">​        strings++;</span><br></pre></td></tr></table></figure><p>但是最后的结果运行函数一并没有改变？</p><p>由于指针数组中每一行类型是数组并没有指针控制，而在每一个指针中却有指针控制。所以<code>*(*strings)</code>便改变了<br>比如对于定义中的<code>*string[2]</code>;<br>输出第一个数组第二个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%c\n&quot;,*string[0]+1);</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;assert.h&quot;</span><br><span class="line">int find_char1(char **,char);</span><br><span class="line">int find_char2(char **,char);</span><br><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123;</span><br><span class="line">    char *string[2] = &#123;&quot;12&quot;,&quot;34&quot;&#125;;</span><br><span class="line">    find_char1(string,&apos;1&apos;);</span><br><span class="line">    printf(&quot;\t%s\n&quot;,*string);</span><br><span class="line">    find_char2(string,&apos;1&apos;);</span><br><span class="line">    printf(&quot;\t%s\n&quot;,*string);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">find_char1(char **strings ,char value)&#123;</span><br><span class="line">    char *string;</span><br><span class="line">    while((string  = *strings++)!=NULL)&#123;</span><br><span class="line">        while(*string !=&apos;\0&apos;)&#123;</span><br><span class="line">            printf(&quot;%c\n&quot;,*string);</span><br><span class="line">            if(*string++ == value)</span><br><span class="line">                return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">find_char2(char **strings,char value)&#123;</span><br><span class="line">    //assert(strings!=NULL);</span><br><span class="line">    while(strings!=NULL)&#123;</span><br><span class="line">        while(**strings!=&apos;\0&apos;)&#123;</span><br><span class="line">            printf(&quot;%c\n&quot;,*(*strings));</span><br><span class="line">            if(*(*strings)++ == value)</span><br><span class="line">                return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        strings++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ASP页面打开缓慢解决办法</title>
      <link href="/2013/05/15/ASP%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%E7%BC%93%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2013/05/15/ASP%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%E7%BC%93%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>  这里要说的是asp页面打开缓慢的问题。而不是打不开的问题。如果直接打不开的话，请先检查asp服务扩展是否开启<br><img src="https://img-blog.csdn.net/20130515224558438" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">​<br>如果网站较多，请建立多个应用程序池。注意不要将.NET的应用程序池与asp的应用程序池混用。可能会造成不可预知的后果。<br>1、新建立一个应用程序池<br><img src="https://img-blog.csdn.net/20130515224729788" alt="图片"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">​</p><p>名称自定义，建议1~2个asp程序公用一个应用程序池。<br>2、给网站新建虚拟目录</p><p><img src="https://img-blog.csdn.net/20130515224748568" alt="图片"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><br>虚拟目录的名称和本地名称相同。</p><p><img src="https://img-blog.csdn.net/20130515224856559" alt="图片"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><br>设置运行脚本权限。</p><p><img src="https://img-blog.csdn.net/20130515225017588" alt="图片"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdn.net/20130515225040009" alt="图片"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><br>如果仅仅是运行asp网站的话，。asp.net的版本设置为1.X即可</p><p><img src="https://img-blog.csdn.net/20130515225108702" alt="图片"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">​<br>虚拟目录的属性下设置指定应用程序池并且允许脚本资源访问。</p><p><img src="https://img-blog.csdn.net/20130515225126436" alt="图片"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>应用程序池还可以进行各种优化设置<br>每次回收都将会提高服务器的相应。<br><img src="https://img-blog.csdn.net/20130515225140373" alt="图片"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">​</p><p>感谢网友<a href="http://user.qzone.qq.com/7377114/" target="_blank" rel="noopener">@爱情水晶</a> 的帮助。、 有什么不足还望多多指教。  </p>]]></content>
      
      
      <categories>
          
          <category> APS.NET </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>WIN8系统按下ctrl按键直接关闭文件夹并结束explorer进程解决方案</title>
      <link href="/2013/05/15/WIN8%E7%B3%BB%E7%BB%9F%E6%8C%89%E4%B8%8Bctrl%E6%8C%89%E9%94%AE%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B9%B6%E7%BB%93%E6%9D%9Fexplorer%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2013/05/15/WIN8%E7%B3%BB%E7%BB%9F%E6%8C%89%E4%B8%8Bctrl%E6%8C%89%E9%94%AE%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B9%B6%E7%BB%93%E6%9D%9Fexplorer%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>已经解决了，原因可能是WIN8安装了谷歌输入法出现了按键冲突，换了百度输入法</p><p>原文提问链接<a href="http://wenwen.soso.com/z/q434552078.htm" target="_blank" rel="noopener">http://wenwen.soso.com/z/q434552078.htm</a></p><p>希望能帮助遇到这个问题的网友</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RedHat-Linux指令</title>
      <link href="/2013/05/08/RedHat-Linux%E6%8C%87%E4%BB%A4/"/>
      <url>/2013/05/08/RedHat-Linux%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">|dev 设备文件</span><br><span class="line">|boot 启动文件</span><br><span class="line">|etc 存放系统的配置文件</span><br><span class="line">|bin 运行文件</span><br><span class="line">|home 用户的住目录</span><br><span class="line">--|用户的配置文件</span><br><span class="line">|lib 库文件</span><br><span class="line">|media 挂在的设备文件</span><br><span class="line">|mnt 挂在的分区</span><br><span class="line">|sbin var sys 相应的程序文件</span><br><span class="line">|root 根用户的主目路：右上角有X的打不开</span><br><span class="line">|查看-显示隐藏文件 </span><br><span class="line">|命令：区分大小写</span><br><span class="line">--|vim 编辑文件</span><br><span class="line">--|cat 打开文件</span><br><span class="line">--|ls 列出文件</span><br><span class="line">  --|ls -a 显示全部文件</span><br><span class="line">  --|ls *    :显示所有的文件或者文件夹，但是有.开头的不可以显示出来。</span><br><span class="line">  --|ls .*    :显示以.开头的隐藏文件</span><br><span class="line">  --|ls ？    :匹配单个的任意字符</span><br><span class="line">  --|ls [1-3]</span><br><span class="line">  --|ls /dev/sd[abcd][1-9]    :显示dev下串口分区的有abcd的并且在1-9范围内的</span><br><span class="line">--|cd /usr/l+tab    :自动检索目录下l开头的文件，自动扩展功能</span><br><span class="line">--|yum --help    :生成该命令的帮助</span><br><span class="line">--|man history    :查看该命令帮助手册</span><br><span class="line">--|history     :运行过得命令</span><br><span class="line">  --|history -w his     :将前面使用过得命令保存到当前目录his 文件夹下，</span><br><span class="line">  --|history -c    :清空history文件</span><br><span class="line">  --|history -r    :将保存的history文件重新写入</span><br><span class="line">  --|!32    :调用history文件中的第32条命令</span><br><span class="line">--|clear    :清屏</span><br><span class="line">--|alias    :对命令起别名：显示当前系统中定义过得别名</span><br><span class="line">  --|alias &apos;aa=history&apos;    :对history设置别名为aa:进对本次登录生效：永久生效需要对配置文件修改</span><br><span class="line">|/home/user/.bashc    :对该文件增加别名可以使命令每次重启之后依旧有效</span><br><span class="line">|通配符：</span><br><span class="line">--|yum -i linuxqq.rpm    :RADHAT下安装QQ的方法</span><br></pre></td></tr></table></figure><h2 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">创建用户</span><br><span class="line">|--useradd zkx ：创建一个用户zkx</span><br><span class="line">  |--useradd -d /home/张三 zzx :指定主目录的用户账户</span><br><span class="line">  |--useradd -u 602 zxx :指定用户ID的用户账户</span><br><span class="line">  |--useradd -g cuser s4 :指定主组群的用户账户</span><br><span class="line">|--passwd zkx ：用来更改密码</span><br><span class="line">|--系统-&gt;管理-&gt;用户和群组 对用户进行设置：系统建立的用户的ID号都是小于500的</span><br><span class="line">|--定位到--&gt;文件系统--&gt;etc--&gt;passwd文件 ：可以看到自己的用户，项目和项目之间用：隔开</span><br><span class="line">cuser:x:500:500:commonuser:/home/cuser:/bin/bash</span><br><span class="line">s4:x:603:500::/home/s4:/bin/bash</span><br><span class="line">用户名：密码：用户的ID号：用户所属组的组的ID号：用户的描述：用户的主目录：用户登录界面的文件保存位置</span><br><span class="line">|--userdel s4 :删除用户s4：但是删不掉用户里面的文件</span><br><span class="line">  |--userdel -r zxx :连用户的主目录一起删掉</span><br><span class="line">|--groupadd m1 :添加一个用户组群</span><br><span class="line">|exit :exit退出root 身份</span><br><span class="line">|--su zkx :切换到zkx的用户身份</span><br><span class="line">  |--su -c &quot;ls /homex&quot; zkx :执行一条命令使用zkx用户权限（需要提示输入密码）</span><br><span class="line"></span><br><span class="line">chmod 740 /etc/sudoers    为这个文件提供保存文件的权限</span><br><span class="line"></span><br><span class="line">编辑sudoers文件：为一个用户提供某种命令的权限</span><br><span class="line">（使用root身份）</span><br><span class="line">------------------------------</span><br><span class="line">##定义用户的别名</span><br><span class="line">User_Alias S=zkx,cuser</span><br><span class="line">Runas_Alias R=root</span><br><span class="line">Cmdn_Alias USER=/usr/sbin/useradd,/usr/sbin/userdel,/user/bin/passwad</span><br><span class="line">##定义群组的别名</span><br><span class="line">Cmdn_Alias GROP=/uer/sbin/group*</span><br><span class="line">#定义权限</span><br><span class="line">S ALL=(R) NOPASSWD:USER,GROP</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line">chmod 440 /etc/sudoers</span><br><span class="line">是配置文件生效</span><br><span class="line"></span><br><span class="line">sudo -l</span><br><span class="line">查看是否已经生效</span><br></pre></td></tr></table></figure><h2 id="第三节"><a href="#第三节" class="headerlink" title="第三节"></a>第三节</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">ls  查看文件，显示当前目录下面的内容。不包括以.开头的。（蓝色是文件夹，黑色是文件名字，绿色表示可执行，红色是压缩，浅蓝色是链接文件，灰色表示其他格式的文件，）</span><br><span class="line"></span><br><span class="line">ls -x 按列输出，横向排序，</span><br><span class="line"></span><br><span class="line">ls -c 按列输出，纵向排序。</span><br><span class="line"></span><br><span class="line">ls -F 目录文件后面加上/ ，  * 为可执行文件    ，让文件类型指示符显示出来。</span><br><span class="line"></span><br><span class="line">ls -R 将当前文件夹下面的子目录所有文件都显示出来。</span><br><span class="line"></span><br><span class="line">ls -rl  以列表形式显示详细信息</span><br><span class="line"></span><br><span class="line">一列            二列    三列         四列      五列              六列                         七列</span><br><span class="line"></span><br><span class="line">drwxr-xr-x.     2       root          root       4096          8月 25 2010          yum.repos.d</span><br><span class="line">-rw-r--r--.  1 root root       813  8月 25 2010 yum.conf</span><br><span class="line">drwxr-xr-x.  4 root root      4096  7月 14 2011 yum</span><br><span class="line">-rw-r--r--.  1 root root       585  6月 24 2010 yp.conf</span><br><span class="line">drwxr-xr-x.  2 root root      4096  7月 14 2011 xml</span><br><span class="line"></span><br><span class="line">lrwxrwxrwx. 1 root root           4  5月 22 23:39 root -&gt; sda1</span><br><span class="line">drwxr-xr-x. 2 root root          60  5月 22 23:39 raw</span><br><span class="line">crw-rw-rw-. 1 root root      1,   8  5月 22 23:39 random</span><br><span class="line">brw-rw----. 1 root disk      1,   9  5月 22 23:39 ram9</span><br><span class="line">第一列：：</span><br><span class="line">第一位：文件的性质 </span><br><span class="line"></span><br><span class="line">d：表示文件夹</span><br><span class="line"></span><br><span class="line">c：是一个设备文件，字符型的设备文件</span><br><span class="line"></span><br><span class="line">b：块设备文件，一个块可能是一个扇区或者几个扇区</span><br><span class="line"></span><br><span class="line">l：表示是一个链接文件     --&gt;表示文件链接所指向的是那个文件</span><br><span class="line"></span><br><span class="line">-：表示普通文件</span><br><span class="line"></span><br><span class="line">后三位：rwx </span><br><span class="line"></span><br><span class="line">r：是读取权限</span><br><span class="line"></span><br><span class="line">w：写权限</span><br><span class="line"></span><br><span class="line">x：执行权限</span><br><span class="line"></span><br><span class="line">第一个rwx是文件拥有者</span><br><span class="line"></span><br><span class="line">再后三位：rwx </span><br><span class="line"></span><br><span class="line">属于拥有者用户所在组的用户的权限。</span><br><span class="line"></span><br><span class="line">最后三位：rwx</span><br><span class="line"></span><br><span class="line">对于其他用户的权限。</span><br><span class="line"></span><br><span class="line">第二列：：文件连接树</span><br><span class="line"></span><br><span class="line">第三列：：拥有者</span><br><span class="line"></span><br><span class="line">第四列：：拥有者所在组的其他用户</span><br><span class="line"></span><br><span class="line">第五列：：文件大小</span><br><span class="line"></span><br><span class="line">第六列：：时间</span><br><span class="line"></span><br><span class="line">第七列：：文件名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">touch abc 新建一个abc 的文件</span><br><span class="line"></span><br><span class="line">gedit abc 编辑文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[cuser@f102 ~]$ file 3     显示文件类型，</span><br><span class="line">3: ASCII text</span><br><span class="line"></span><br><span class="line">[cuser@f102 ~]$ file /dev/sda2</span><br><span class="line">/dev/sda2: block special</span><br><span class="line"></span><br><span class="line">[cuser@f102 ~]$ file -f f      读取f文件中的内容（以列表形式），判断列表里面所有文件的类型（f中内容为1&lt;br&gt;2）</span><br><span class="line">1: ASCII text</span><br><span class="line">2: cannot open `2&apos; (No such file or directory)</span><br><span class="line">:  cannot open `&apos; (No such file or directory)</span><br><span class="line"></span><br><span class="line">[cuser@f102 ~]$ more  -d /etc/termcap       查看长文档的一些命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat 命令查看文档，cat 文件路径名</span><br><span class="line"></span><br><span class="line">cat 建立新文档     cat &gt;s1.txt   用ctrl+d 结束编辑           &gt;是输入重定向</span><br><span class="line"></span><br><span class="line">cat s1.txt s2 &gt;s3      将s1.txt 和s2 链接起来   保存到s3 下面</span><br><span class="line"></span><br><span class="line">[cuser@f102 ~]$ mkdir a1       建立一个文件夹</span><br><span class="line"></span><br><span class="line">[cuser@f102 a1]$ mkdir a1/b1/c1/d1 -p  创建多层的目录</span><br><span class="line"></span><br><span class="line">[cuser@f102 a1]$ rmdir a1/b1/c1/d1 删除这些目录最后的一个文件夹（删除文件夹要确保是空的）</span><br><span class="line"></span><br><span class="line">[cuser@f102 ~]$ rmdir -p a1/a1/b1/c1  删除所有的文件夹。（先删除最后的文件夹，以此向上，如果是空的就删除，不是空的就不删）</span><br><span class="line"></span><br><span class="line">[cuser@f102 ~]$ mv a1 aa1   将a1改为aa1   当第二个参数存在，完成的就是移动。，第二个参数必须是一个目录才可以移动。</span><br><span class="line"></span><br><span class="line">[cuser@f102 ~]$ mv 1 3 aa    将 1 3 都移动到aa 里面</span><br><span class="line"></span><br><span class="line">[cuser@f102 aa]$ mv -bi 2 aa1   - 后面连续两个参数，可以使用。该指令b 表示覆盖文件的时候自动备份，i是在覆盖文件之前有相应的询问。</span><br><span class="line"></span><br><span class="line">[cuser@f102 aa]$ mv -bfS .dak 3 aa1   强制替换文件，不做任何提问。    指令S是要对备份文件制定备份后缀。</span><br><span class="line"></span><br><span class="line">[cuser@f102 aa]$ rm -r aa1    删除aa1并且删除里面的所有文件    指令r是递归的删除一个目录，删除文件也可以使用用，后面的参数必须是一个目录的名字，不可以是文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[cuser@f102 aa]$ mkdir  aa1/b1/b2 -p</span><br><span class="line">[cuser@f102 aa]$ rm -ir aa1</span><br><span class="line">rm：是否进入目录&quot;aa1&quot;? Y</span><br><span class="line">rm：是否进入目录&quot;aa1/b1&quot;? Y</span><br><span class="line">rm：是否删除目录 &quot;aa1/b1/b2&quot;？Y</span><br><span class="line">rm：是否删除目录 &quot;aa1/b1&quot;？Y</span><br><span class="line">rm：是否删除目录 &quot;aa1&quot;？Y                    提示确认删除的参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[cuser@f102 aa]$ cp f /tmp    将文件拷贝到tmp     ，可以拷贝多个，最后一个是文件夹</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 ~]# cp -r a1 aa1     将a1文件夹 拷贝到aa1 中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看文件的类型：</span><br></pre></td></tr></table></figure><h2 id="第四节"><a href="#第四节" class="headerlink" title="第四节"></a>第四节</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">find 查找文件命令</span><br><span class="line"></span><br><span class="line">--|find /dev -type d -print      将dev下面所有类型是文件夹的东西显示出来</span><br><span class="line">--|find /dev -type b -print      查找块设备文件</span><br><span class="line"></span><br><span class="line">--|find /etc -name &quot;passwd*&quot;        查找以passwd开头的文件</span><br><span class="line"></span><br><span class="line">--|find /etc -name &quot;passwd&quot; -exec ls -l &#123;&#125; \;        查找文件passwd开头的，以列表详细信息形式显示出来。</span><br><span class="line"></span><br><span class="line">--|find /etc -size +10000k -ok ls -l &#123;&#125; \;            查找大于1WK 的文件</span><br><span class="line"></span><br><span class="line">实例：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 cuser]# find /etc -size +1000k -ok ls -l &#123;&#125; \;</span><br><span class="line">&lt; ls ... /etc/selinux/targeted/policy/policy.24 &gt; ? y</span><br><span class="line">-rw-r--r--. 1 root root 5820086  7月 14 2011 /etc/selinux/targeted/policy/policy.24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--|find /root -perm 644 -exec ls -l &#123;&#125; \;         按照用户的权限查找文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-rw-r--r--. 1 root root 129 12月  4 2004 /root/.tcsh</span><br><span class="line"></span><br><span class="line">解释：644</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读写执行</span><br><span class="line"></span><br><span class="line">rw-   头三位，权限是110 。数字6</span><br><span class="line">有权限就是1 ，没有权限的就是0，每三位转换为二进制，</span><br><span class="line"></span><br><span class="line">r-- 代表4.。。。。。</span><br><span class="line"></span><br><span class="line">查询指定文件拥有者文件</span><br><span class="line"></span><br><span class="line">[root@f102 cuser]# find /home -user root              </span><br><span class="line">/home</span><br><span class="line">/home/cuser/100</span><br><span class="line">/home/cuser/a</span><br><span class="line">/home/cuser/a~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 cuser]# find /home -user root -exec ls -l &#123;&#125; \;</span><br><span class="line">总用量 24</span><br><span class="line">drwx------. 34 cuser cuser 4096  5月 30 00:01 cuser</span><br><span class="line">drwx------.  4 stu1  users 4096 10月 12 2011 stu1</span><br><span class="line">drwx------.  4 stu11 stu11 4096 10月 19 2011 stu11</span><br><span class="line">drwx------.  4 stu12 stu12 4096 10月 19 2011 stu12</span><br><span class="line">drwx------. 27 stu13 stu13 4096 10月 19 2011 stu13</span><br><span class="line">drwx------.  4 stu14 stu14 4096 10月 19 2011 stu14</span><br><span class="line">-rw-r--r--. 1 root root 6 11月  2 2011 /home/cuser/100</span><br><span class="line">-rw-r--r--. 1 root root 37 10月 26 2011 /home/cuser/a</span><br><span class="line">-rw-r--r--. 1 root root 37 10月 26 2011 /home/cuser/a~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">七天之内修改过的日志文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 cuser]# find /var/log -mtime 7 -exec ls -l &#123;&#125; \;</span><br><span class="line">七天之内没有修改过的日志文件</span><br><span class="line"></span><br><span class="line">[root@f102 cuser]# find /var/log -mtime +7 -exec ls -l &#123;&#125; \;</span><br><span class="line">总用量 4</span><br><span class="line">drwx------. 2 root root 4096  8月 24 2010 old</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">按照已知文件为标准，查找新的文件或者老的文件</span><br><span class="line">查找比1新的文件</span><br><span class="line"></span><br><span class="line">[root@f102 cuser]# find /home/cuser -newer /home/cuser/1</span><br><span class="line">/home/cuser</span><br><span class="line">/home/cuser/.xsession-errors</span><br><span class="line">/home/cuser/2</span><br><span class="line">/home/cuser/.local/share/gvfs-metadata</span><br><span class="line">/home/cuser/.local/share/gvfs-metadata/root-30cf838a.log</span><br><span class="line">/home/cuser/.local/share/gvfs-metadata/home-cedbf307.log</span><br><span class="line"></span><br><span class="line">查看分区情况  这些信息存在在 proc /partitons 下面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 cuser]# fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 317.9 GB, 317891895808 bytes</span><br><span class="line">255 heads, 63 sectors/track, 38648 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk identifier: 0xf0b1ebb0</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        7770       11979    33816793+  83  Linux</span><br><span class="line">/dev/sda2           31675       35522    30909060    5  Extended</span><br><span class="line">/dev/sda5           31675       32209     4297356   82  Linux swap / Solaris</span><br><span class="line">/dev/sda6           32210       33483    10233373+   c  W95 FAT32 (LBA)</span><br><span class="line"></span><br><span class="line">63个扇区。38648</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sda</span><br><span class="line"></span><br><span class="line">sd 串口，a 第一个口。b 第二个口</span><br><span class="line"></span><br><span class="line">小于4的分区不可以让逻辑分区占用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分区调整</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 cuser]# fdisk -h</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> fdisk [options] &lt;disk&gt;    change partition table</span><br><span class="line"> fdisk [options] -l &lt;disk&gt; list partition table(s)</span><br><span class="line"> fdisk -s &lt;partition&gt;      give partition size(s) in blocks</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -b &lt;size&gt;                 sector size (512, 1024, 2048 or 4096)</span><br><span class="line"> -c                        switch off DOS-compatible mode</span><br><span class="line"> -h                        print help</span><br><span class="line"> -u &lt;size&gt;                 give sizes in sectors instead of cylinders</span><br><span class="line"> -v                        print version</span><br><span class="line"> -C &lt;number&gt;               specify the number of cylinders</span><br><span class="line"> -H &lt;number&gt;               specify the number of heads</span><br><span class="line"> -S &lt;number&gt;               specify the number of sectors per track</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">挂载分区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 cuser]# mount -t vfat /dev/sda6 /mnt/c </span><br><span class="line"></span><br><span class="line">编辑 /etc/fstab可以编辑挂在分区配置文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/dev/sda6/mnt/cvfatdefaults0 0</span><br><span class="line">添加一行。可以在重启之后直接挂载上去</span><br></pre></td></tr></table></figure><h2 id="第五节"><a href="#第五节" class="headerlink" title="第五节"></a>第五节</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">|ifconfig</span><br><span class="line"></span><br><span class="line">配置网络环境命令</span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# ifconfig</span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 10:78:D2:93:C6:ED  </span><br><span class="line">          inet addr:192.168.31.177  Bcast:192.168.31.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::1278:d2ff:fe93:c6ed/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:259983 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:156970 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:100 </span><br><span class="line">          RX bytes:369104215 (352.0 MiB)  TX bytes:11998939 (11.4 MiB)</span><br><span class="line">          Memory:fbec0000-fbee0000 </span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:454 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:454 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:23140 (22.5 KiB)  TX bytes:23140 (22.5 KiB)</span><br><span class="line"></span><br><span class="line">virbr0    Link encap:Ethernet  HWaddr C6:2D:65:28:26:4A  </span><br><span class="line">          inet addr:192.168.122.1  Bcast:192.168.122.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:25 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 b)  TX bytes:4220 (4.1 KiB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|ifconfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# ifconfig eth1 192.168.31.111 netmask 255.255.255.0 up ^C</span><br><span class="line">设置一个IP以及子网眼吗，以及激活状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# ifconfig eth1</span><br><span class="line">查看是IP地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# hostname</span><br><span class="line">f102</span><br><span class="line">显示当前的主机名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# hostname f111</span><br><span class="line">更改自己的主机名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置默认网关路由：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# route add default gw 192.168.31.1</span><br><span class="line"></span><br><span class="line">更改DNS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# gedit /etc/resolv.conf</span><br><span class="line">更改DNS的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line"></span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看软件是否安装：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# rpm -qa |grep vsftp</span><br><span class="line">vsftpd-2.2.2-6.el6.i686</span><br><span class="line">查询软件vsftp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">制作FTP服务器：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# rpm -ivh ftp-0.17-51.1.el6.i686.rpm </span><br><span class="line">warning: ftp-0.17-51.1.el6.i686.rpm: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY</span><br><span class="line">Preparing...                ########################################### [100%]</span><br><span class="line">   1:ftp                    ########################################### [100%]</span><br><span class="line">安装rpm软件包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看服务运行状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# service vsftpd status</span><br><span class="line">vsftpd 已停</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重启服务：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# /etc/init.d/vsftpd restart</span><br><span class="line">关闭 vsftpd：                                              [确定]</span><br><span class="line">为 vsftpd 启动 vsftpd：                                    [确定]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关闭服务：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# service vsftpd stop</span><br><span class="line">关闭 vsftpd：                                              [确定]</span><br><span class="line"></span><br><span class="line">开启服务：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f102 桌面]# service vsftpd start</span><br><span class="line">为 vsftpd 启动 vsftpd：                                    [确定]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置开机启动的服务</span><br><span class="line"></span><br><span class="line">ntsysv </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ftp使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f111 桌面]# ftp localhost</span><br><span class="line">Connected to localhost (127.0.0.1).</span><br><span class="line">220 (vsFTPd 2.2.2)</span><br><span class="line">Name (localhost:root): anonymous</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system type is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; ls</span><br><span class="line">227 Entering Passive Mode (127,0,0,1,159,114).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-r--r--    1 0        0               0 Jun 05 17:15 123</span><br><span class="line">drwxr-xr-x    2 0        0            4096 May 26  2010 pub</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt; get 123</span><br><span class="line">local: 123 remote: 123</span><br><span class="line">227 Entering Passive Mode (127,0,0,1,81,102).</span><br><span class="line">150 Opening BINARY mode data connection for 123 (0 bytes).</span><br><span class="line">226 Transfer complete.</span><br><span class="line">登录本地FTP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用匿名用户登录</span><br><span class="line"></span><br><span class="line">查看所有的文件</span><br><span class="line"></span><br><span class="line">下载文件123</span><br><span class="line"></span><br><span class="line">下载到了桌面上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bye推出ftp服务器登录状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更改ftp文件配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@f111 桌面]# gedit /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>李兴华Jsp教程-使用过滤器之后,出现打不开页面的问题</title>
      <link href="/2013/05/02/%E6%9D%8E%E5%85%B4%E5%8D%8Ejsp%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B9%8B%E5%90%8E-%E5%87%BA%E7%8E%B0%E6%89%93%E4%B8%8D%E5%BC%80%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2013/05/02/%E6%9D%8E%E5%85%B4%E5%8D%8Ejsp%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B9%8B%E5%90%8E-%E5%87%BA%E7%8E%B0%E6%89%93%E4%B8%8D%E5%BC%80%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>过滤器是依照李兴华的一本JSP书籍写的.,应用到MVC设计模式中出现了打不开页面的问题,.经过百度知道的提问,得到了解决,.</p><p><a href="http://zhidao.baidu.com/question/546458767?quesup2&amp;oldq=1" target="_blank" rel="noopener">http://zhidao.baidu.com/question/546458767?quesup2&amp;oldq=1</a></p><p>原来的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zkx.filter;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"><span class="comment">//private String charSet;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span><span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line"><span class="comment">//this.charSet = config.getInitParameter("charset"); //获取配置文件中设置的编码格式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request,ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException ,ServletException</span>&#123;</span><br><span class="line">request.setCharacterEncoding(<span class="string">"GBK"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line">配置文件</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">zkx</span>.<span class="title">filter</span>.<span class="title">EncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">charSet</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">GBK</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">---------------------------------------------</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">将doFilter改为如下解决问题</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request,ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            request.setCharacterEncoding(<span class="string">"GBK"</span>);          <span class="comment">//增加了chain的doFilter 的方法.</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        </span><br><span class="line">        response.setCharacterEncoding(<span class="string">"GBK"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">顺利解决问题            request.setCharacterEncoding(<span class="string">"GBK"</span>);          <span class="comment">//增加了chain的doFilter 的方法.</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        </span><br><span class="line">        response.setCharacterEncoding(<span class="string">"GBK"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">顺利解决问题</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JSP页面加载后直接跳转到Servlet</title>
      <link href="/2013/03/27/JSP%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E5%88%B0Servlet/"/>
      <url>/2013/03/27/JSP%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E5%88%B0Servlet/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SQL基础教程</title>
      <link href="/2012/03/17/SQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2012/03/17/SQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库的工作原理及概念"><a href="#数据库的工作原理及概念" class="headerlink" title="数据库的工作原理及概念"></a>数据库的工作原理及概念</h2><p>一、 启动安装SQL server没得说，有点电脑知识的都会，这里就不再详细解释了。</p><p>关于win7的安装仔细看一下连接<a href="http://www.cnblogs.com/icewee/articles/2019783.html" target="_blank" rel="noopener">http://www.cnblogs.com/icewee/articles/2019783.html</a></p><p>二、 信息是对各种事物的存在方式，运动状态和互相联系特征的一种表达和陈述。</p><p>数据是描述符号的记录，是信息的载体，是信息的具体表达形式，。</p><p>数据处理是将数据转化为信息，如对数据的分类，组织，编码，储存，查询，维护，加工，计算，传播，以及打印。 数据管理是指数据的收集，整理，组织储存和查询等操作。</p><h3 id="数据库技术有三个管理阶段"><a href="#数据库技术有三个管理阶段" class="headerlink" title="数据库技术有三个管理阶段"></a>数据库技术有三个管理阶段</h3><p>1，人工管理阶段，</p><p>2，文件系统阶段，</p><p>3，数据库系统阶段，</p><p>主要记数据库管理阶段 优点： 数据库结构化，（简而回答就是由MSDN管理数据库，减少冗余，数据共享，一个数据可以在多个应用程序中使用，）  较高的数据共享性，（数据库将对整个系统起作用，不像人工管理，一组数据对应一个程序，最大好处减少冗余。） 较高的独立性，（与应用程序相互独立，物理独立，逻辑独立，（数据定义修改，联系变更，不影响程序）)</p><p>由DBMS统一管理，（作用数据共享并发，可以同时存取统一数据，而不会发生冲突，） DBMS：是广泛的数据库管理系统，作用，1，安全保密，防止非法获取，2，完整性保护，正确性，有效性，相容性，主要目的并发存取的时侯，对多用户操作加以控制协调，3，在数据破坏是进行恢复。</p><h3 id="数据库管理的结构图："><a href="#数据库管理的结构图：" class="headerlink" title="数据库管理的结构图："></a>数据库管理的结构图：</h3><p>数据库→DBMS→程序1，程序2，程序3</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>是指长期存在计算机内的，有组织，可共享的数据集合，简而答之就是一个数据堆，记录着许多个人信息或者什么的，但是排列有序，冗余较小，</p><p>DBMS对其管理，也是应用程序后台的存取库，以文件形式存在计算机上，是数据库系统的操作对象，</p><h3 id="数据据库管理系统："><a href="#数据据库管理系统：" class="headerlink" title="数据据库管理系统："></a>数据据库管理系统：</h3><p>建立使用围护。替应用程序访问数据库，创建，查询更新插入修改，检索，维护工作，保证数据库的安全完整，</p><h3 id="数据库应用系统："><a href="#数据库应用系统：" class="headerlink" title="数据库应用系统："></a>数据库应用系统：</h3><p>凡是使用数据库技术管理，都称为数据库应用系统</p><h3 id="数据库用户称为三种："><a href="#数据库用户称为三种：" class="headerlink" title="数据库用户称为三种："></a>数据库用户称为三种：</h3><p>1终端：使用软件的普通用户，看不要数据库的内部，</p><p>2应用程序员：对数据库结构设计。分析，开发，维护，设计数据库系统中的各类程序。</p><p>3数据库管理员：最高级的用户，设计定义数据库系统，监督和控制数据库系统的使用和运行，改进和重组数据库系统，优化性能，定义数据的安全和完整性约束，备份与恢复数据库。</p><h3 id="数据库管理系统的功能："><a href="#数据库管理系统的功能：" class="headerlink" title="数据库管理系统的功能："></a>数据库管理系统的功能：</h3><p>数据定义与操纵，数据库运行控制，数据库组织存储管理，建立维护数据库，</p><h3 id="数据库通信接口："><a href="#数据库通信接口：" class="headerlink" title="数据库通信接口："></a>数据库通信接口：</h3><p>提供与其他软件进行通信的功能，联机处理接口，远程作业输入接口。</p><h3 id="三级模式："><a href="#三级模式：" class="headerlink" title="三级模式："></a>三级模式：</h3><p>内模式，是物理模式，物理存储状态，一个数据库只有一个内模式。 模式：逻辑i模式，对数据库中全部数据的逻辑结构和特征进行描述，是所有用户的公共视图，数据库管理系统提供模式描述语言来定义模式，一个数据库只有一个模式，。 外模式：数据库用户都能够看见的，是局部数据的逻辑结构和特征的描述，一个数据库可以有多个外模式，一个应用程序只能使用一个外模式，</p><h3 id="二级映像："><a href="#二级映像：" class="headerlink" title="二级映像："></a>二级映像：</h3><p>外模式/模式：当模式改变外模式不必一起改动，仅仅改动映像。 模式/内模式：可以保证物理数据的独立性（模式改变内模式不必改变）</p><h3 id="数据库的发展："><a href="#数据库的发展：" class="headerlink" title="数据库的发展："></a>数据库的发展：</h3><p>分布式数据库<a href="http://baike.baidu.com/view/68389.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/68389.htm</a></p><p>面向对象数据库<a href="http://baike.baidu.com/view/682410.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/682410.htm</a></p><p>多媒体数据库<a href="http://baike.baidu.com/view/297200.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/297200.htm</a></p><p>数据仓库<a href="http://baike.baidu.com/view/19711.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/19711.htm</a></p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="信息存在的三种状态（三种世界）"><a href="#信息存在的三种状态（三种世界）" class="headerlink" title="信息存在的三种状态（三种世界）"></a>信息存在的三种状态（三种世界）</h3><p>现实世界：顾名思义，就是现实眼睛看到的世界，客观世界。实体！想要了解的可以看《当下的力量》这类哲学书籍</p><p>信息世界：第一章提到的概念，就是大脑所想象到的模型，抽象的。</p><p>数据世界：这章的重点要了解的，就是计算机的天下，计算机的世界。全部都是数据，（其实一开始都是由01010000101001这样的字符组成，）是信息世界中信息变成数据的产物。数据世界具有量化（把图像样本连续变化的模拟量或密度值转换成离散数字量样本值的过程。），物化（实物化）在数据世界都是以数据模型描述事物！</p><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>根据自己的观点想象的，（提到N遍了。。）</p><p>1实体：客观存在的东西！</p><p>2属性：就是对实体进行详细的解释，一个实体可以有多个属性，但是只能有一个码（码就是能够唯一认可这个实体的东西，就是看到这个码就可以知道是那个实体。在后面会有提到表的主键和外键，主键就是一个码，当然主键可能是由多个属性拼接而成，也可以是一个属性。）</p><p>3码：上面已经提到，要注意的是一个表，一个实体里面可以有多个码，但不是多个主键，主键是码，但是码不是主键，当作主键的码称之为主码，其他称之为候选吗</p><p>4实体型：用实体的名字和属性的名字集合来刻画的同一个类的实体，就是一个实体模块。</p><p>例如：“学生（姓名，学号，性别）”类似于后面的一个表。</p><p>5实体集；没有必要特别的解释，就是好多一样实体型的集合。例如全体学生（简单的东西无可解释）</p><p>6联系：</p><p>就是找到一个属性，必定可以在这个属性的基础上联想到另外的一个或者几个属性，分为三种，</p><p>一对一联系 一个部门只有一个经理</p><p>一对多联系 一个老师教多个学生</p><p>多对多联系 一个学生选多门课，一门课有多个学生选。</p><p>（联系就是联系，就是有联系，有关系，好像你爸爸跟你有关系。。哪那么多解释！）</p><p>实体-联系模型</p><p>简称为E-R模型</p><p><img src="file:///C:/Users/keen/AppData/Local/Temp/msohtmlclip1/01/clip_image001.jpg" alt="img"></p><p>来张图片，其他不解释了。自己看书！</p><p>它与计算机和DBMS无关，只是人们为了方便理解画得图，最重要转化为数据模型</p><h3 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h3><p>根据计算机的系统观点进行建模。（在这里解释一下数学建模，就是将现实中的事件转化为数学公式模块进行处理，与我们计算机行业相类似，都是将现实问题转化为另一种形式进行简单的处理，在编程语言中是将某个问题编制成一个个函数，随时调用，方便简洁！）</p><p>是严格定义概念的集合，表述了系统的静态特征，动态特征和完整性约束条件</p><p>由数据结构，数据操作，数据完整性约束组成，</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>对数据库静态特征的描述（对数据的物理排列，框架（结构架子）等等描述），研究的对象是数据库的组成部分，在数据库系统添加数据模型的时候要根据数据结构的定义添加，比如增次结构就依照层次的类型添加。暂时分为3个模型</p><h4 id="1层次模型"><a href="#1层次模型" class="headerlink" title="1层次模型"></a>1层次模型</h4><p>解释：</p><p>就是树状的层次结构，<img src="file:///C:/Users/keen/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="img">如图所示，每个结点表示一个记录类型（就是一个类型，如学校）每个线段表示一个联系（就是两个类型的关系）只有一个结点没有双亲结点（双亲结点就是父结点，就是上级的枝杈）。称之为根节点。</p><p>根节点以外的其他节点有且只有一个双亲结点，上级与下级之间是一对一的联系。最后的结点称之为叶。</p><p>可以进行查询，删除，更新，插入</p><p>查询必须通过双亲结点，</p><p>删除一个类型的时候其下面的子分类将会全部删除，</p><p>更新的时候要保持下面子女节点的一致。</p><p>插入的时候必须有双亲结点可以插入（比如要插入在数计系的一个学生，但是没有数计系，就不能插入）</p><p>利：方便，联系固定，容易实现</p><p>弊：插入删除麻烦，不能直接显示多对多联系，查询要通过双亲结点。</p><h4 id="2网状模型"><a href="#2网状模型" class="headerlink" title="2网状模型"></a>2网状模型</h4><p>解释：允许一个结点有多个双亲结点，允许多个结点没有双亲结点，</p><p><img src="file:///C:/Users/keen/AppData/Local/Temp/msohtmlclip1/01/clip_image003.jpg" alt="img"></p><p>插入允许插入尚未确定双亲结点值的子女结点值。</p><p>删除允许只删除双亲结点值，</p><p>只更新指定记录即可。</p><p>查询可以有多种路径，不必要通过某一个双亲结点。</p><h4 id="3关系数据模型"><a href="#3关系数据模型" class="headerlink" title="3关系数据模型"></a>3关系数据模型</h4><p>解释：用二维表格表示实体与实体之间的数据模型称之为关系模型。</p><p>关系：一个关系就是一个表。</p><p>元组：一行称之为一个元组。</p><p>属性：前面已经介绍过，这里每一个列称之为一个属性，</p><p>域：就是属性的取值范围，当给属性创建约束的时候它的域相对就发生了变化</p><p>关系模式：与之前的实体型差不多，一个表名（属性1，属性2）</p><p>关键字和码：不用解释，确定唯一元组的属性</p><p>候选关键字和候选码：简而答之就是另外的关键字，但是不叫关键字，也能标识元组</p><p>主键，主码：许多关键字中指定的一个或者一组属性</p><p>主属性，非主属性：关键字就是主属性，不包含任意候选码的属性就是非主属性</p><p>外键或外码：在这个表里面不是主属性，而在另外一个表里面却是主属性，则称之这个属性是这个关系的外码（我这里说的表，关系，都是一样的）</p><p>例：创建外码：  alter table 表</p><p>​                                  Add constraint  约束名 foreign  key （属性1） reference 表2（属性1）</p><p>将表中的属性1设置成了外键，这个外键在表2中是主键。</p><p>层次模型和网状模型称为非关系模型</p><h3 id="数据操作："><a href="#数据操作：" class="headerlink" title="数据操作："></a>数据操作：</h3><p>顾名思义，对数据进行删除，插入，修改，检索，更新，对数据库进行动态变化，其中检索查询是用的最多的</p><p>数据模型要定义操作的确切含义，操作符号，操作规则，现实操作语言。。。</p><h3 id="数据的完整性约束："><a href="#数据的完整性约束：" class="headerlink" title="数据的完整性约束："></a>数据的完整性约束：</h3><p>对数据的某些值项的约束，关于数据状态和状态变化的约束集合，保证数据的正确有效一致。例如以后会提到unique（唯一）约束，primary key（主键）约束，foreign key （外键）check（检查） default（默认）约束都是完整性的约束，以后会举例如何应用这些约束。</p><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><p>关系数据库就是一张二维表（一列一列的表），表格里面各个数据都互相有关系，称之为关系数据库，但是二维表不一定是关系数据库。</p><h3 id="关系的约束："><a href="#关系的约束：" class="headerlink" title="关系的约束："></a>关系的约束：</h3><p>每一列的数据类型相同，满足同一个约束条件。</p><p>各列属性的名称不能重合，数据类型可以相同。</p><p>任意两行（元组）不能完全相同</p><p>列的排列次序部分先后。（学号在第一列还是姓名在第一列，但是在使用 insert into(列名1，列名2) values(数据1，数据2)插入数据的时候列明其实可以不填写的，不填写的话要注意排列的次序。否则会出错的）</p><p>元组的位置不分先后。</p><p>每个属性必须是单一的类型。（不能够在班级属性再分下级属性，关系结构不能够嵌套。）</p><h3 id="关系模式："><a href="#关系模式：" class="headerlink" title="关系模式："></a>关系模式：</h3><p>关系是关系模式中的一个存在的状态或者内容。</p><p>关系模式是型，关系是他的内容，关系模式是静态的关系是动态的</p><p>关系模式和关系统称为关系（就是那个二维表。关系模式可以说是表的框架，关系是表的内容）</p><p>关系模式是一个五元组（就是五个元素组合）</p><p>R（U,D,dom，F）</p><p>R 关系的名称</p><p>U 属性的集合</p><p>D 属性的域</p><p>dom 属性向域的映像集合。</p><p>F属性间的互相依赖集合。</p><h3 id="关系数据库："><a href="#关系数据库：" class="headerlink" title="关系数据库："></a>关系数据库：</h3><p>采用关系模型的数据库</p><p>关系数据库有型和值的区别，</p><p>型：若干个关系模型框架。</p><p>值：在某一时刻对应关系的集合。</p><h3 id="关系的完整性："><a href="#关系的完整性：" class="headerlink" title="关系的完整性："></a>关系的完整性：</h3><p>实体完整性</p><p>主码不能出现空值</p><p>参照完整性</p><p>简而答之就是，若AB是通过外键连接的，A的外码R必须是空值或者B中存在的值，</p><p>用户自定义完整性</p><p>就是自己对表中属性的约束条件，必须遵循，否则会出错。</p><h3 id="关系运算："><a href="#关系运算：" class="headerlink" title="关系运算："></a>关系运算：</h3><p>传统的集合造作：并，差，交，笛卡尔积</p><p>专门的关系元算：投影，选择，连接，除法（笛卡尔积的逆运算）</p><p>比较运算：大于，小于。。。</p><p>逻辑运算：与或非。。</p><p>后面进行详细的解释。</p><h3 id="传统的集合运算："><a href="#传统的集合运算：" class="headerlink" title="传统的集合运算："></a>传统的集合运算：</h3><p>1笛卡尔积 最大限度的元组集合，用R的第一个元组与S 的每一个元组进行联合。得到完整的关系，组合成一个表。（可以是两个不同的关系模型）</p><p>2并 具有相同关系模型的，进行并操作，取所有元组集合。然后删掉相同的元组</p><p>3差 R和S两个关系，并且关系模式相同，R-S是属于R但是不属于S 的集合关系。</p><p>4交 既属于R又属于S的集合</p><h3 id="专门的关系运算："><a href="#专门的关系运算：" class="headerlink" title="专门的关系运算："></a>专门的关系运算：</h3><p>1选择</p><p>选择满足指定条件的元组，（类似于后面的查询功能）</p><p>2投影</p><p>选取出几个列，删除相同的元组，因为当删除掉几列之后，会有以前两个元组只有一列中的数据不同，而删除掉那一列之后便会出现相同的元组，然而根据关系的基本约束条件不能有相同的元组，所以会被自动的略除</p><p>3连接</p><p>在对两个表进行连接的时候早注意的是只有当两个表中有相同的列的时候才可以连接。</p><h3 id="连接运算过程"><a href="#连接运算过程" class="headerlink" title="连接运算过程"></a>连接运算过程</h3><p>确定属性列</p><p>确定参与比较的属性列</p><p>逐一选取R中的元组与S中与其符合比较关系的元组进行拼接</p><h4 id="小于连接"><a href="#小于连接" class="headerlink" title="小于连接"></a>小于连接</h4><p>在笛卡尔积的条件下取满足连接条件的值</p><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p>与小于连接含义相同，只是必须取两个相等的数值的元组</p><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>把有重复的属性去掉，如两个表都有学号属性则在连接之后就会去掉一个学号属性，最后的连接结果不会减少，但是行数列数却减少了，减少冗余。 也是等值连接，只是将相同的属性进行等值连接。</p><h2 id="关系规范化基础"><a href="#关系规范化基础" class="headerlink" title="关系规范化基础"></a>关系规范化基础</h2><h3 id="数据依赖："><a href="#数据依赖：" class="headerlink" title="数据依赖："></a>数据依赖：</h3><p>函数依赖</p><p>多值依赖</p><p>连接依赖</p><p>主要说明函数依赖：也是本章的重点 定义： 如果对于属性x每一个值都有一个Y与之相对应。例如：每一个学号都有一个成绩与它相对应，则Y函数依赖于X。就是说X的值决定Y的值，X不可以重复，Y可以重复。</p><h4 id="非平凡函数依赖和平凡函数依赖："><a href="#非平凡函数依赖和平凡函数依赖：" class="headerlink" title="非平凡函数依赖和平凡函数依赖："></a>非平凡函数依赖和平凡函数依赖：</h4><p>如果X→Y且Y属于X。就是说X是两个属性的集合，而Y是其中的一个属性。则称之为平凡函数依赖。</p><p>如果X→Y且Y不属于X，则称之为非平凡函数依赖。</p><h4 id="完全函数依赖和部分函数依赖："><a href="#完全函数依赖和部分函数依赖：" class="headerlink" title="完全函数依赖和部分函数依赖："></a>完全函数依赖和部分函数依赖：</h4><p>就是说如果X→Y的时候如果有个一Z也属于X，并且Z→Y也成立则称之为部分函数依赖。</p><p>X→Y并且如果任意一个属于X的属性集合Z都不能满足Z→Y的话那么称之为完全函数依赖。</p><h3 id="传递函数依赖："><a href="#传递函数依赖：" class="headerlink" title="传递函数依赖："></a>传递函数依赖：</h3><p>如果X→Y成立Y→Z成立，并且不可以逆向传递，就是说Y→X成立。那么就称之为传递函数依赖。</p><p>码的函数依赖表示 若K→U（全部属性）则称之K为R上的候选码（其中一个是主码）</p><p>外码：如同外键，不再解释</p><h3 id="关系规范化："><a href="#关系规范化：" class="headerlink" title="关系规范化："></a>关系规范化：</h3><p>目的: 解决关系模式中存在的数据冗余，插入和删除异常，更新异常。</p><p>基本思想是消除数据依赖中的不适合的部分，使各个关系模式达到某种程度的分离，使一个关系描述一个概念，实体，或者实体之间的关系。</p><p>一共有六种范式，在此介绍三种范式以及BC范式。</p><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>就是没有重复的列，重复的属性。并且每一个属性都是不可以再次进行分解的。</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>非主属性完全依赖与主关键字。并且在满足第一范式的基础之上。</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>没有传递依赖与码的非主属性，就是说不能有非主属性依赖于其他非主属性。并且在第二范式的基础上。</p><h4 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h4><p>对于任何非平凡函数依赖X→Y，X均包含码。 就是说在第二范式的基础上，所有的非主属性都完全依赖于每个候选码，不能依赖于一个非主属性的集合，或者非主属性。主属性完全依赖于每个不包含它的候选码。</p><h2 id="数据库和表"><a href="#数据库和表" class="headerlink" title="数据库和表"></a>数据库和表</h2><p>本章和第九章乃是重中之重！ </p><p>前面的567章就不再讲解，</p><p>需要注意的是第五章将E-R模型转化为关系模式。</p><p>其实倒也是不难，只是可能会在试题中出现。</p><p>关系模式结构</p><p>学生（学号，姓名，出生日期，所在系，年纪，平均成绩）</p><p>第六章不用讲解。</p><p>第七章的内容在第八章和第九章里面会完全的体现出来。这里不再讲解。</p><p>下面讲解正题：</p><h3 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h3><p>数据库是由</p><p>主数据文件   后戳文件名 mdf          数据库必须有主数据文件，且只有一个</p><p>辅助数据文件  后戳文件名 ndf         没必要有，也可以有多个</p><p>事务日志文件  后戳文件名 ldf       恢复数据库文件的日志文件，可以有多个，至少有一个，</p><p>可以有多个。</p><p>Server 2005不强制使用这样的后戳名字，只是起到了标识的作用</p><p>数据库文件组:</p><p>多个数据库文件组成的一个整体</p><h3 id="主文件组"><a href="#主文件组" class="headerlink" title="主文件组"></a>主文件组</h3><p>包含系统表，主要的数据库文件，没有指派给其他文件组的其他文件。</p><p>1、创建主文件组的时候可以利用代码语句“create database 文件组名”这是创建最简单的数据库文件组<img src="file:///C:/Users/keen/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img">（其实就是创建了一个数据库），不用设定任何条件，全部取默认值，</p><p>(自动创建一个日志文件大小为1/4大小总数据文件。</p><p>并且日志文件的文件名和数据库名默认相同。</p><p>只是后戳不同。自动设置名字name为“数据库名_data”。</p><p>自动设置默认路径名filename。</p><p>自动设置初始大小size与模版数据库中主文件大小size一致。</p><p>其他数据文件为默认1MB，最小是512KB。</p><p>文件最大可增长到的尺寸MAXSIZE是默认充满磁盘。</p><p>默认每次增加的大小FILEGOWTH的值是10%，每次扩展最小值是64KB，增长可以按照百分比或者大小进行设定。)</p><p>2、使用ALTER database可以更改数据库中的属性。</p><p>例：       </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> ALTER database</span><br><span class="line"></span><br><span class="line">Modify file</span><br><span class="line"></span><br><span class="line">(name =’逻辑文件名’，  //必须填写逻辑文件名</span><br><span class="line"></span><br><span class="line">Size= 文件大小，</span><br><span class="line"></span><br><span class="line">Maxsize=增长限制)</span><br></pre></td></tr></table></figure><p>3、使用file group 创建文件组。</p><p>例：        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库2</span><br><span class="line"></span><br><span class="line">On primary      --主文件组</span><br><span class="line"></span><br><span class="line">(name=&apos;数据库&apos;,</span><br><span class="line"></span><br><span class="line">filename=&apos;F:\临时\数据库.mdf&apos;</span><br><span class="line"></span><br><span class="line">),           --有个逗号，在与日志文件中间不必添加逗号。但是两个日志文件中间需要添加逗号。</span><br><span class="line"></span><br><span class="line">Filegroup  fg1            --定义一个文件组 grope就是组的意思，多简单。。所以外语好的人可别浪费了</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line"></span><br><span class="line">name=&apos;数据库名&apos;,</span><br><span class="line"></span><br><span class="line">filename=&apos;F:\临时\数据库名.ndf&apos;                --与创建数据库填写的属性相同。</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">   --alter database 数据库</span><br><span class="line"></span><br><span class="line">   --add</span><br><span class="line"></span><br><span class="line">Log on             --file</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line"></span><br><span class="line">name=&apos;数据库名&apos;,</span><br><span class="line"></span><br><span class="line">filename=&apos;F:\临时\数据库名.ldf&apos;)</span><br></pre></td></tr></table></figure><p>（说明：这个–是标注，后面的在SQL中不会运行。）</p><p>文件组不能独立于数据库文件创建。文件组是在数据库中对文件进行分组的一种管理机制。数据实际上是依附于表来存在的，我们将表放入到文件组中，而文件组是一个逻辑的概念，其实体是辅助数据库文件(.ndf),所以就等于将我们指定的数据放入到了指定的辅助数据库文件中，然后如果将这些辅助数据库文件放入在不同的磁盘分区中，就可以最终实现有针对性的对相应的数据实现性能的优化。</p><p>这样就创建了一个名字是“数据库2”的一个数据库，包含有日志文件，主数据文件，文件组。</p><p>下面也可以通过修改表添加一个文件组文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alter database 数据库2</span><br><span class="line"></span><br><span class="line">add file </span><br><span class="line"></span><br><span class="line">(name=&apos;文件组&apos;,</span><br><span class="line"></span><br><span class="line">filename=&apos;F:\临时\文件组.ndf&apos;</span><br><span class="line"></span><br><span class="line">) to filegroup fg1</span><br></pre></td></tr></table></figure><p>可以增加文件组文件到“数据库2” <img src="file:///C:/Users/keen/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p><p>修改数据库：</p><p>增加数据库空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER database</span><br><span class="line">Modify file                //修改文件属性</span><br><span class="line">(name =’逻辑文件名’，  //必须填写逻辑文件名</span><br><span class="line"></span><br><span class="line">Size= 文件大小，</span><br><span class="line"></span><br><span class="line">Maxsize=增长限制)</span><br></pre></td></tr></table></figure><h2 id="减小数据库文件大小"><a href="#减小数据库文件大小" class="headerlink" title="减小数据库文件大小"></a>减小数据库文件大小</h2><p>数据库名字上面右击选择，任务，收缩，文件选项。</p><p>出现收缩数据库对话框，保持默认设置，确定，收缩完毕。</p><p>收缩特定的数据文件，日志文件，任务，收缩，文件选项。</p><p>自动收缩可以在选项页面设置，</p><p>（不会小于初始的大小）</p><h3 id="删除数据库文件"><a href="#删除数据库文件" class="headerlink" title="删除数据库文件"></a>删除数据库文件</h3><p>Alter dababase 数据库名</p><p>Remove file 逻辑文件名  </p><h3 id="数据库更名"><a href="#数据库更名" class="headerlink" title="数据库更名"></a>数据库更名</h3><p>Sp_renamedb ‘原数据库名’，’现数据库名’</p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>Drop database 数据库名</p><p>对于数据库的建立操作还是相对简单的，毕竟没有什么深奥的。只有一些简单的创建修改死固定格式而已。这一章先写一半发表出去，创建修改表相对要复杂一点。</p><h2 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h2><h3 id="创建一个表"><a href="#创建一个表" class="headerlink" title="创建一个表"></a>创建一个表</h3><p>在SQL中创建一个表其实简单的很，并且这个表与EXCEL的表基本相同（这样大家不至于畏惧SQL，其实它并不难，甚至比C++要简单的多。），并且可以说是就是同样的表，因为在SQL中可以将SQL创建的表导出成EXCLE表格，并且可以将EXCLE表格导入SQL中进行操作，不同的只是SQL相对较为复杂，并且功能较多（是非常多）。</p><p>使用management studio 视图创建表就不再详细讲解了，简单的很，主要说明使用SQL语句进行创建表</p><p>创建表的时候可以使用create table 表名  创建表</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use 数据库 </span><br><span class="line"></span><br><span class="line">go</span><br><span class="line"></span><br><span class="line">create table XSS</span><br><span class="line"></span><br><span class="line">(学号 char (12) ,  </span><br><span class="line"></span><br><span class="line">姓名 char(8),</span><br><span class="line"></span><br><span class="line">性别 char(2)       </span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在创建表的前面可以添加 “use 数据库的名字”便可以转到指定的数据库，这这个数据库里面创建表。<img src="file:///C:/Users/keen/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img">这里创建的表的列没有任何约束，例如主键约束primary key 默认约束 default ‘默认约束值’  not null 也是一种约束，不允许空值的约束。</p><p>在创建表的时候只要在列明的最后面天上SQL语句就可以了，也可以在创建表之后再添加约束</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use 数据库</span><br><span class="line"></span><br><span class="line">go</span><br><span class="line"></span><br><span class="line">Alter table XSS</span><br><span class="line"></span><br><span class="line">add constraint X_M check (性别=&apos;男&apos; and 姓名=&apos;女&apos;)  --增加约束，中间是约束名X_M（约束名的起名方式自定义，一般写约束列的首字母+约束名的首字母）  check是选择约束（在括号里面的内容选择）</span><br><span class="line"></span><br><span class="line">命令已成功完成。</span><br><span class="line"></span><br><span class="line">create table XSS</span><br><span class="line"></span><br><span class="line">(学号 char (12)  primary key,  </span><br><span class="line"></span><br><span class="line">姓名 char(8),</span><br><span class="line"></span><br><span class="line">性别 char(2)       </span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>命令已成功完成。</p><p>删除表的时候可以使用 drop table XSS 简单快捷</p><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>修改表只需要alter table 表名  即可以修改，下面详细介绍</p><h4 id="修改列的属性"><a href="#修改列的属性" class="headerlink" title="修改列的属性"></a>修改列的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alter table xss</span><br><span class="line"></span><br><span class="line">Alter column 姓名varchar(50) null    --将列的数据类型改为了varchar型，就是可以自动变动所占内存大小的char字符型。适用于设定不定字数的列，比如备注列。</span><br></pre></td></tr></table></figure><h4 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Alter table XSS</span><br><span class="line"></span><br><span class="line">Add 出生日期 smalldatetime   null      --small 低精度的时间</span><br><span class="line"></span><br><span class="line">constraint  fg                         --约束+约束名</span><br><span class="line"></span><br><span class="line">default getdate()                      --默认约束为系统当前时间</span><br></pre></td></tr></table></figure><h4 id="删除一列的数据"><a href="#删除一列的数据" class="headerlink" title="删除一列的数据"></a>删除一列的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 列名 = &apos;&apos;</span><br></pre></td></tr></table></figure><h4 id="删除一列"><a href="#删除一列" class="headerlink" title="删除一列"></a>删除一列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table XSS</span><br><span class="line">drop column 出生日期</span><br></pre></td></tr></table></figure><h2 id="列约束和表约束"><a href="#列约束和表约束" class="headerlink" title="列约束和表约束"></a>列约束和表约束</h2><p>本章主要讲的几个约束有主键约束，primary key  外键约束  foreign key  唯一性约束  unique   检查约束  check     默认值约束 default  </p><h3 id="创建主键约束的几种方式："><a href="#创建主键约束的几种方式：" class="headerlink" title="创建主键约束的几种方式："></a>创建主键约束的几种方式：</h3><p>直接在创建表的一列后面添加约束，</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Create table asd</span><br><span class="line"></span><br><span class="line">(学号 char   primary key,</span><br><span class="line"></span><br><span class="line">姓名  char</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样的命令式成功的，注意在这里我没有对char设定它的大小系统将会自动设置为char(1)的大小。如果设定的是varchar不设定所占字节的话，系统将设定为1，并且自动增长的时候不会超过所设的字节。例如varchar(10)就不会超过10。</p><p>还有一种对于主键可以设置表级约束，就是当一个表里面需要两个主键的时候，可以这样设定</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Create table sdf</span><br><span class="line"></span><br><span class="line">(姓名char ,</span><br><span class="line"></span><br><span class="line">班级char ,</span><br><span class="line"></span><br><span class="line">年龄char,</span><br><span class="line"></span><br><span class="line">成绩char</span><br><span class="line"></span><br><span class="line">Primary key (姓名,班级)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样的命令也是成功的，要注意的是在这里最后一行本应当写成“constraint PK_XB Primary key (姓名,班级)”然而我并没有这样写，我是想证明这样写也是正确的，但是，这样的话对于constraint约束的名字将会系统自动取值。下面我执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_helpconstraint sdf</span><br></pre></td></tr></table></figure><p>这样的命令来查询 sdf表里面的约束 </p><p>出现了约束名PK<strong>sdf</strong>03317E3D</p><p><img src="file:///C:/Users/keen/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>如图所示，这就是没有定义约束名的后果，主要体现在当需要删除某个约束的时候，你不知道约束名，也就变的异常的复杂。删除约束的语法后面会提到。</p><h3 id="还有一种就是使用alter-table-添加约束"><a href="#还有一种就是使用alter-table-添加约束" class="headerlink" title="还有一种就是使用alter table 添加约束"></a>还有一种就是使用alter table 添加约束</h3><p>先讲一下格式</p><p>Alter table 表名                       –修改一个表</p><p>Add [constraint 约束名]               –增加约束，[]这个括号里面的内容可以不填写，上面已经提到过，不再解释。</p><p>Primary key                        –增加的是个主键</p><p>Clustered|nonclustered             –这里可以选填聚集或者非聚集索引，如果添加的是聚集索引，那么将不能再设置其他聚集索引（如果不是主键的设置了聚集索引，那么将不能再设置主键。），因为主键本身就是聚集索引，而一个表里面只能由一个聚集索引。</p><p>(column[,……n])           –这里是确定有几个列要设置主键约束。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alter table sdf </span><br><span class="line"></span><br><span class="line">Add constraint PK_xm  primary key (姓名)</span><br></pre></td></tr></table></figure><p>命令是成功的。</p><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><p>alter table sdf</p><p>drop constraint 约束名</p><p>利用modify可以改变一列的数据格式</p><p>alter table XSS</p><p>modify 学号 int    将列明改为 int的数据类型</p><h3 id="创建删除unique约束"><a href="#创建删除unique约束" class="headerlink" title="创建删除unique约束"></a>创建删除unique约束</h3><p>Unique是对列约束成唯一值的约束。类似于候选主键，也是一般对候选主键的约束。</p><h4 id="1，-在创建标的时候设定唯一性约束。"><a href="#1，-在创建标的时候设定唯一性约束。" class="headerlink" title="1， 在创建标的时候设定唯一性约束。"></a>1， 在创建标的时候设定唯一性约束。</h4><p>直接在列名后面添加constraint UK_xs unique</p><h4 id="2，利用修改表创建unique约束，"><a href="#2，利用修改表创建unique约束，" class="headerlink" title="2，利用修改表创建unique约束，"></a>2，利用修改表创建unique约束，</h4><p>Alter table xss </p><p>Add unique (姓名)</p><p>命令已成功完成。</p><p>删除约束同主键约束相同</p><h3 id="创建删除foreign-key-约束"><a href="#创建删除foreign-key-约束" class="headerlink" title="创建删除foreign key 约束"></a>创建删除foreign key 约束</h3><p>可以是实现表和表直接的联系，在创建视图的时候可以体现出来，插入数据的时候也会因为有外键约束而可能插入不成功</p><p>依然有两种创建方法</p><h4 id="1，-创建表的时候在后面添加约束"><a href="#1，-创建表的时候在后面添加约束" class="headerlink" title="1， 创建表的时候在后面添加约束"></a>1， 创建表的时候在后面添加约束</h4><p>格式： 学生号 char (12) Constraint XS_CH foreign key references 主表(学生号)</p><h4 id="2，-在修改表中添加"><a href="#2，-在修改表中添加" class="headerlink" title="2， 在修改表中添加"></a>2， 在修改表中添加</h4><p>Alter table 选课 </p><p>Add constraint  foreign key(学生号) references 学生(学生号)</p><h3 id="创建删除check约束"><a href="#创建删除check约束" class="headerlink" title="创建删除check约束"></a>创建删除check约束</h3><p>与上面类似，</p><p>Constraint ck_sj check(价格&lt;50)</p><p>或者</p><p>Alter table xss</p><p>Add constraint ck_sj check (成绩<100 and="" 成绩="">0)</100></p><p>删除与之前相同</p><h3 id="创建删除default约束"><a href="#创建删除default约束" class="headerlink" title="创建删除default约束"></a>创建删除default约束</h3><p>在后面直接填上 default 默认值       即可</p><p>例如</p><p>Alter table xss</p><p>Add Constraint df_xb default ‘男’</p><p>书上所说的 getdate()是系统当前时间。后面会详细提到。</p><p>要注意的是设置默认值的时候要记得所设置的数据格式与原来的数据格式要相同，并且在插入数据的时候如果设置了默认值那么插入数据要将所插入的那个数据写成default 或者</p><p>inster into （在这里面不写所设定默认值的列） values （数据，数据 )</p><h3 id="表的数据操作"><a href="#表的数据操作" class="headerlink" title="表的数据操作"></a>表的数据操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>Inster into （列名） valuse（数据，数据）</p><h4 id="修改数据类型"><a href="#修改数据类型" class="headerlink" title="修改数据类型"></a>修改数据类型</h4><p>利用modify可以改变一列的数据格式</p><p>alter table XSS</p><p>modify 学号 int    将列名改为 int的数据类型</p><h4 id="删除表里的行"><a href="#删除表里的行" class="headerlink" title="删除表里的行"></a>删除表里的行</h4><p>Delete 表名 where 列名 in （数据） –也可以用not in （某一列），在这里删除满足条件的行</p><p>这里可以限制where 列名 btween 数据 and 数据 可以取两个数据之间的所有行</p><p>很灵活的</p><h4 id="删除全部内容而不删除表"><a href="#删除全部内容而不删除表" class="headerlink" title="删除全部内容而不删除表"></a>删除全部内容而不删除表</h4><p>Delete from 表名</p><h4 id="删除某一列"><a href="#删除某一列" class="headerlink" title="删除某一列"></a>删除某一列</h4><p>Alter table 表</p><p>Dorp column 列名</p><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><p>Drop table 表名</p><p>到此基础内容已将完毕，可能有所欠缺，如果觉得不足希望同学们给点指导。但是书本上的内容基本就这样了，如果后续有想到内容会补充上的，下一章是数据库的核心内容。select查询！</p><h2 id="数据库查询（一）"><a href="#数据库查询（一）" class="headerlink" title="数据库查询（一）"></a>数据库查询（一）</h2><p>本章是整本书的核心内容，也是考试的最重点的内容，按照书上的顺序往下讲解。</p><h3 id="基本查询："><a href="#基本查询：" class="headerlink" title="基本查询："></a>基本查询：</h3><p>Select  列名字             –要查询出来的几列，可以使用聚合函数</p><p>Into  新表名               –如果要将查询出来的数据添加到新建的表，则在这里写上要创建的新表名</p><p>From  来自于的表         – 查询来自于哪个表</p><p>Where  条件               –查询约束条件</p><p>Group  by  列             –按照这个列进行分组，相同的分在同一组。</p><p>Having  条件              –在where 中不能使用聚合函数，在这里却可以使用，</p><p>Order  by  列明 asc| desc           – 对某一列进行升序或者降序排序</p><p>例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select 学生.姓名 as 大于的姓名               --这里的as是将查询结果的列名取为新的</span><br><span class="line"></span><br><span class="line">into  linshi</span><br><span class="line"></span><br><span class="line">from 学生,选课</span><br><span class="line"></span><br><span class="line">where 学生.学生号=选课.学生号</span><br><span class="line"></span><br><span class="line">group by 学生.姓名</span><br><span class="line"></span><br><span class="line">having count(*)&gt;=2</span><br><span class="line"></span><br><span class="line">order by 学生.姓名</span><br></pre></td></tr></table></figure><p>这个语句是用来查询选修课程大于等于2的所有学生姓名，并且按照姓名进行升序排序，将查询结果赋予一个新表linshi </p><p>在这里要利用group by进行排序，否则执行错误，因为使用having的情况下select后面的列必须在group中出现，</p><h3 id="查询的条件约束关键字"><a href="#查询的条件约束关键字" class="headerlink" title="查询的条件约束关键字"></a>查询的条件约束关键字</h3><p>比较运算符：就是&gt;&lt;=   !&gt;   not 什么的，</p><p>确定范围   between and ， not between and   例between @a and @b 介于@a和@b直间 </p><p>确定集合  in  ，not  in        in后面可以是一个集合，也是in和=的差别</p><p>字符匹配  like ，not like         是模糊查询用到的</p><p>空值  is null  ，is not  null          判定是不是空值</p><p>多重条件  and  ，or  ，not          如果三个都存在的话按照  not ，and ，or 的顺序判定</p><h3 id="模糊查询的通配符"><a href="#模糊查询的通配符" class="headerlink" title="模糊查询的通配符"></a>模糊查询的通配符</h3><p>%  ：包含零个或者多个字符串的任意字符串，</p><p>_   ：单个字符</p><p>[  ] ：指定范围的单个字符，如：在里写上一些字符则在这几个字符里面选择</p><p>[^  ] ： 指不再这里面的其他字符。</p><p>格式：like ‘    ’   内添加通配符。</p><h3 id="复合条件查询："><a href="#复合条件查询：" class="headerlink" title="复合条件查询："></a>复合条件查询：</h3><p>使用and or not 函数的语句</p><h3 id="聚合函数："><a href="#聚合函数：" class="headerlink" title="聚合函数："></a>聚合函数：</h3><p>包括 sum()  ， avg()  ，min() ， max()  ，count()  </p><p>Select中可以使用聚合函数</p><h3 id="分组查询："><a href="#分组查询：" class="headerlink" title="分组查询："></a>分组查询：</h3><p>使用group by进行分组</p><p>例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Select 性别 ,count (性别)</span><br><span class="line"></span><br><span class="line">From 学生</span><br><span class="line"></span><br><span class="line">Group by 性别         --将性别相同的分到一个组。</span><br><span class="line"></span><br><span class="line">Having是对group by 的进一步查询，相当于where 但是可以使用聚合函数</span><br><span class="line"></span><br><span class="line">With cube</span><br></pre></td></tr></table></figure><p>在结尾使用此函数将添加一行汇总行，如果查询中有平均成绩，则再添加一行是汇总的全部的平均成绩，（不支持聚合函数）</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select 课程号,avg(成绩),count (学生号)</span><br><span class="line"></span><br><span class="line">from 选课</span><br><span class="line"></span><br><span class="line">group by 课程号</span><br><span class="line">with cube</span><br></pre></td></tr></table></figure><p><img src="file:///C:/Users/keen/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img">会多一行这样的元组（如果对两个列进行分组（课程号和专业），那么会出现第一列的平均成绩和第二列的平均成绩，和总的平均成绩）</p><h3 id="With-rollup-的使用"><a href="#With-rollup-的使用" class="headerlink" title="With rollup 的使用"></a>With rollup 的使用</h3><p>（不支持聚合函数）</p><p>对每一个汇总组进行生成行。生成与with一样的行。并且最后还会生成一个与with cube 一样的行、</p><p>例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select 课程号,专业,avg(成绩)</span><br><span class="line"></span><br><span class="line">from 选课,学生</span><br><span class="line"></span><br><span class="line">where 学生.学生号=选课.学生号</span><br><span class="line"></span><br><span class="line">group by 课程号,专业             --各个课程号的各个专业进行汇总，（如果专业在前面则是每一个专业的平均成绩，课程在前面则是每一门课程的平均成绩，最后再来一次总的平均成绩）</span><br><span class="line"></span><br><span class="line">with rollup              --对课程号汇总，不计专业，查询课程号的平均成绩，然后再查询都不计的平均成绩</span><br></pre></td></tr></table></figure><p>查询了每门专业每门课程的平均成绩和每门课程的平均成绩和总的平均成绩</p><h3 id="数据汇总"><a href="#数据汇总" class="headerlink" title="数据汇总"></a>数据汇总</h3><p>Compute子句（产生一个附加的汇总行，）</p><p>有两种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学生号,姓名</span><br><span class="line">from 学生</span><br><span class="line">where 专业=&apos;电商&apos;</span><br><span class="line">compute count (学生号)</span><br></pre></td></tr></table></figure><p>这类是对前面查询的结果进行汇总，汇总了学生号的个数。单独列出一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 学生号,课程号,成绩</span><br><span class="line">from 选课</span><br><span class="line">order by 学生号</span><br><span class="line">compute sum (成绩) by 学生号</span><br></pre></td></tr></table></figure><p>对每一个不同的学生号进行汇总，分出多行汇总成绩总和行，在每一个查询结果后面。</p><h2 id="数据库查询（二）"><a href="#数据库查询（二）" class="headerlink" title="数据库查询（二）"></a>数据库查询（二）</h2><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内连接-Inner-join"><a href="#内连接-Inner-join" class="headerlink" title="内连接 Inner join"></a>内连接 Inner join</h4><p>内连接也叫连接，是最早的一种连接。还可以被称为普通连接或者自然连接，内连接是从结果表中删除与其他被连接表中没有匹配行的所有行，所以内连接可能会丢失信息。 例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Select 姓名,选课.课程号,成绩</span><br><span class="line"></span><br><span class="line">from 选课Inner join 学生                 --进行连接</span><br><span class="line"></span><br><span class="line">On  选课.学生号 = 学生.学生号            --此行不可少，</span><br><span class="line"></span><br><span class="line">Where 学生.学生号=&apos;010002&apos;               --条件可以省略</span><br></pre></td></tr></table></figure><p>这样就查询了010002所有选课课程号和他的成绩。</p><p>上面的语句相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Select 姓名,选课.课程号,成绩</span><br><span class="line"></span><br><span class="line">From 选课,学生</span><br><span class="line"></span><br><span class="line">Where 选课.学生号=学生.学生号and 学生.学生号=&apos;010002&apos;</span><br></pre></td></tr></table></figure><p>这样使用了一个连接符 and  用于合并条件.</p><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>将同一个表的不同行连接起来,连接这样的表需要给表名起两个别名才行,是它在逻辑上称为两个表,在一定程度会方便查询.如要查询成绩大于A同学的所有学生.从而不必涉及子查询. 例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Select a.学生号,a.课程号,a.成绩</span><br><span class="line">From 选课a inner join 选课b               --自连接与内链接使用的连接语句相同，都是inner join </span><br><span class="line">On a.课程号=&apos;0001&apos; and a.成绩&gt;b.成绩and b.学生号=&apos;010003&apos;  and b.课程号=&apos;0001&apos;                 --设定条件</span><br><span class="line"></span><br><span class="line">group by   a.课程号,a.学生号,a.成绩             --按学生号分组，当然不管什么用</span><br></pre></td></tr></table></figure><p>这里就是查询了大于010003学生0001课程的成绩的学生的信息</p><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>外连接只限制一个表的数据行，而不限制另一个表的数据行，当然也可以都不限制的。只能用在两个表里面</p><p>1、左外连接（对条件的左边不加以限制）left [outer] join 结构： Selec 查找的列</p><p>From 表1  left[outer] join 表2</p><p>On 表1.列1=表2.列2</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 姓名,学生.学生号,选课.课程号</span><br><span class="line"></span><br><span class="line">from 学生left join 选课</span><br><span class="line"></span><br><span class="line">on 学生.学生号=选课.学生号</span><br></pre></td></tr></table></figure><p>将左边表的信息完全显示，一一对应右边的表。</p><p>2、右外连接（对右边的不加以限制）right[outer] join</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Selec 查找的列</span><br><span class="line"></span><br><span class="line">From 表1  right[outer] join 表2</span><br><span class="line"></span><br><span class="line">On 表1.列1=表2.列2</span><br></pre></td></tr></table></figure><p>不再举例</p><p>3、全外连接（对两边都不加以限制）full[outer] join</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Selec 查找的列</span><br><span class="line"></span><br><span class="line">From 表1  right[outer] join 表2</span><br><span class="line"></span><br><span class="line">On 表1.列1=表2.列2</span><br></pre></td></tr></table></figure><p>不再举例。相当于前面说过的</p><h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h4><p>使用关键字 cross join 来创建</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 姓名,课程号,成绩</span><br><span class="line"></span><br><span class="line">from 学生cross join 选课</span><br></pre></td></tr></table></figure><p>它不需要添加on或者where来限制连接条件，并且不能用on 来限制，但是可以用where 来限制，如果添加限制，那么最后的结果就会和 inner join 的连接相同</p><p>作用：包含了所连接的两个表所有行的全部组合。就是将第一个表的每一项都与第二个表的每一项相连接。</p><h4 id="将三个表进行连接"><a href="#将三个表进行连接" class="headerlink" title="将三个表进行连接"></a>将三个表进行连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Select 表1，表2，表3</span><br><span class="line"></span><br><span class="line">From 表1 inner join 表2</span><br><span class="line"></span><br><span class="line">On 表1.列1=表2.列2</span><br><span class="line"></span><br><span class="line">Inner join 表3</span><br><span class="line"></span><br><span class="line">On 表1.列1=表3.列3</span><br></pre></td></tr></table></figure><h3 id="使用update-可以修改表中的数据"><a href="#使用update-可以修改表中的数据" class="headerlink" title="使用update 可以修改表中的数据"></a>使用update 可以修改表中的数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update 学生 set 姓名=&apos;张小明&apos;</span><br><span class="line"></span><br><span class="line">from 学生</span><br><span class="line"></span><br><span class="line">where 姓名=&apos;张小亮&apos;</span><br></pre></td></tr></table></figure><p>将学生表中的行名列中的张凯旭修改为张泽旭</p><p>这里还有一个用途，就是可以为所有行都插入同样的信息</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Update 学生</span><br><span class="line"></span><br><span class="line">Set </span><br><span class="line"></span><br><span class="line">出生日期 =’1992-01-01’</span><br></pre></td></tr></table></figure><p>将在学生表的出生日期列全部插入同样的出生日期。</p><h3 id="将查询结果赋予一个定义的变量"><a href="#将查询结果赋予一个定义的变量" class="headerlink" title="将查询结果赋予一个定义的变量"></a>将查询结果赋予一个定义的变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">declare @avg  int</span><br><span class="line"></span><br><span class="line">Select @avg=avg(成绩)</span><br><span class="line"></span><br><span class="line">From 选课,学生</span><br><span class="line"></span><br><span class="line">Where 学生.学生号=选课.学生号and 姓名=@xm</span><br><span class="line"></span><br><span class="line">declare @avg  int</span><br><span class="line"></span><br><span class="line">select @avg =(Select avg(成绩)</span><br><span class="line"></span><br><span class="line">From 选课,学生</span><br><span class="line"></span><br><span class="line">Where 学生.学生号=选课.学生号and 姓名=@xm)</span><br></pre></td></tr></table></figure><p>这里可以使用两种格式进行赋值,</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><h4 id="1、无关子查询"><a href="#1、无关子查询" class="headerlink" title="1、无关子查询"></a>1、无关子查询</h4><p>就是指与外部的查询没有关联，可以单独执行内部的查询命令。并且在执行操作的时候优先执行子查询，将子查询的结果赋予外部的查询。</p><p>（注：子查询中不可以使用 order by 它只能是对最终的查询结果进行排序。）</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select 姓名,专业</span><br><span class="line"></span><br><span class="line">from 学生</span><br><span class="line"></span><br><span class="line">where 学生.学生号in </span><br><span class="line"></span><br><span class="line">(select 学生.学生号</span><br><span class="line"></span><br><span class="line">from 选课,学生</span><br><span class="line"></span><br><span class="line">where 选课.学生号=学生.学生号and 选课.课程号=&apos;0002&apos;</span><br><span class="line"></span><br><span class="line">group by 学生.学生号</span><br><span class="line"></span><br><span class="line">having avg(成绩)&gt;60  </span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这个子查询我选择了一个稍复杂的例子，这里查询了所有选课课程号是0002的并且平均成绩大于60的学生</p><p>注意在使用聚合函数的时候只能使用having 代替where 然而使用having的时候又必须要先分组才行，</p><h4 id="2、相关子查询"><a href="#2、相关子查询" class="headerlink" title="2、相关子查询"></a>2、相关子查询</h4><p>子查询的执行依赖于外部的查询，多数情况下子查询的where 中引用了外部查询的表</p><p>相关子查询的执行过程：</p><p>1， 子查询为外部查询每执行一次，外部查询将子查询所引用的列的值传给子查询，</p><p>2， 如果子查询的任何行与其匹配，则外部查询返回结果行，</p><p>3， 再返回第一步，处理外部表的每一行。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Select 学生号,课程号,成绩</span><br><span class="line"></span><br><span class="line">From 选课 a               --外部查询来自于一个选课表,起别名 a </span><br><span class="line"></span><br><span class="line">Where 成绩&lt;</span><br><span class="line"></span><br><span class="line">(select avg(成绩)          --查询平均成绩</span><br><span class="line"></span><br><span class="line">From 选课 b                 --平均成绩来自于选课表  ,起别名 b </span><br><span class="line"></span><br><span class="line">Where a.课程号=b.课程号      --将外部的课程号与内部的课程号相关联.</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里的语句用来查询比该课程平均成绩低的学生的学生号,课程号,成绩</p><p>这里每查询一个课程号的平均成绩,就引用一次外部表的课程号,并且将选课表的成绩与平均成绩相比较,如果成立,则放到查询的行,并且依次比较,再进行查询一次另一个课程号的平均成绩,如此反复,</p><p>而无关子查询仅仅将子查询结果出来之后进行赋予外部查询的where 列</p><h4 id="3、带有exists的子查询（相关子查询）"><a href="#3、带有exists的子查询（相关子查询）" class="headerlink" title="3、带有exists的子查询（相关子查询）"></a>3、带有exists的子查询（相关子查询）</h4><p>Exists是用来判断所查询的结果是否有行,就是是否有结果,如果有结果返回真,如果没有结果,返回假,前面可以加上NOT 就是not exists 则测试的结果就会相反.</p><p>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select 姓名</span><br><span class="line"></span><br><span class="line">from 学生</span><br><span class="line"></span><br><span class="line">where exists (</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line"></span><br><span class="line">from 选课</span><br><span class="line"></span><br><span class="line">where 学生号=学生.学生号</span><br><span class="line"></span><br><span class="line">and 课程号=&apos;0003&apos;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>判断内部子查询是不是真,如果是真,则将查询到的学生号等于学生表的学生号的值,并且课程号等于0003的学生的姓名查询出来.因为外部的查询只查询了姓名</p><p>如果是假的,则返回了空值,.</p><h4 id="另一种exists-的用法"><a href="#另一种exists-的用法" class="headerlink" title="另一种exists 的用法"></a>另一种exists 的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if exists (select *</span><br><span class="line"></span><br><span class="line">from 选课</span><br><span class="line"></span><br><span class="line">where  课程号=&apos;0003&apos;)</span><br><span class="line"></span><br><span class="line">print &apos;存在&apos;</span><br><span class="line"></span><br><span class="line">else print &apos;不存在&apos;</span><br></pre></td></tr></table></figure><p>这里使用exists 是比较好用的，它判断了课程号等于0003的是否存在，如果有这个课程号，则打印存在，反之，打印不存在，<img src="file:///C:/Users/keen/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><h2 id="数据库查询（三）"><a href="#数据库查询（三）" class="headerlink" title="数据库查询（三）"></a>数据库查询（三）</h2><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询其实就是将连个查询结果进行联合起来，变成更多的结果，</p><p>使用SQL语句 union all         –这里如果使用了all 那么将会不过虑重复的项。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Select 姓名</span><br><span class="line"></span><br><span class="line">From 选课,学生</span><br><span class="line"></span><br><span class="line">Where 课程号=&apos;c001&apos; and 选课.学生号=学生.学生号</span><br><span class="line"></span><br><span class="line">Union</span><br><span class="line"></span><br><span class="line">Select 姓名</span><br><span class="line"></span><br><span class="line">From 选课,学生</span><br><span class="line"></span><br><span class="line">Where 课程号=&apos;E002&apos; and 选课.学生号=学生.学生号</span><br></pre></td></tr></table></figure><p>就是将E002和C001两个课程号的表连接查询起来了</p><h4 id="联合查询有两个基本规则、"><a href="#联合查询有两个基本规则、" class="headerlink" title="联合查询有两个基本规则、"></a>联合查询有两个基本规则、</h4><p>1、 所有查询的列数和查询的列的顺序必须相同。，</p><p>2、 数据类型必须兼容</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Select 1,2</span><br><span class="line"></span><br><span class="line">Union </span><br><span class="line"></span><br><span class="line">Select 1.3,5.6</span><br></pre></td></tr></table></figure><p>这样的查询是可以联合的，因为他们可以进行隐性转化，将讲个数据格式转换成一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Select &apos;1&apos;,3</span><br><span class="line"></span><br><span class="line">Union</span><br><span class="line"></span><br><span class="line">Select 5,41</span><br></pre></td></tr></table></figure><p>这样的也可以转化，虽然上面的是字符型的但是可以转换成整形的1然而如果是字符型的‘zhang’这样的字符，则无法转化</p><p>当然最好在查询的时候使用相同的数据类型的数据格式。</p><h3 id="对查询结果排序"><a href="#对查询结果排序" class="headerlink" title="对查询结果排序"></a>对查询结果排序</h3><p>就是使用order by语句进行排序。</p><p>在查询结果的最后一行添加order by 列 ，列</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Select 学生号,成绩</span><br><span class="line"></span><br><span class="line">From 选课</span><br><span class="line"></span><br><span class="line">Order by 学生号desc ,成绩      -- 将查询结果先按照学生号降序，按照成绩升序</span><br></pre></td></tr></table></figure><p>这里如果不在列的后面添加desc 则默认是ASC升序，</p><h3 id="储存查询结果"><a href="#储存查询结果" class="headerlink" title="储存查询结果"></a>储存查询结果</h3><p>就是在select 后面使用into 进行储存，将查询到的结果储存在一个新的表里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Slelct 姓名，成绩</span><br><span class="line"></span><br><span class="line">Into 新表</span><br><span class="line"></span><br><span class="line">From 学生，选课</span><br><span class="line"></span><br><span class="line">Where 学生.学生号=选课.学生号 </span><br><span class="line"></span><br><span class="line">下次再执行 select * from  新表</span><br><span class="line"></span><br><span class="line">即可以查询到新表的表项。</span><br><span class="line"></span><br><span class="line">使用insert into 将一个或者多个表的查询到的数据赋值到一个新的表里面。</span><br><span class="line"></span><br><span class="line">Create table 成绩</span><br><span class="line"></span><br><span class="line">(学生号char(7),</span><br><span class="line"></span><br><span class="line">课程号char(4),</span><br><span class="line"></span><br><span class="line">成绩int </span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Insert into</span><br><span class="line"></span><br><span class="line">成绩(学生号,课程号,成绩)</span><br><span class="line"></span><br><span class="line">Select *                --select 不用再括号里面，不能使用values 、</span><br><span class="line"></span><br><span class="line">From 选课</span><br><span class="line"></span><br><span class="line">Where 成绩&gt;=80</span><br></pre></td></tr></table></figure><p>这样就完成了将查询的值插入到新的表里面</p><h3 id="使用控制流语句"><a href="#使用控制流语句" class="headerlink" title="使用控制流语句"></a>使用控制流语句</h3><p>用来进行顺序，分支，循环，存储过程，等程序设计。提高编程语言的控制能力</p><p>控制流语句一下几项</p><p>Set 同于对变量进行赋值，select 也可以当作赋值语句，相对来说select 赋值语句要比set 高级一些，它可以对多个变量进行同时赋值</p><p>Begin … end 定义一个语句块</p><p>If … else 条件语句</p><p>Case 多分支语句</p><p>While 循环语句</p><p>Continue 重新开始下一个循环</p><p>Break 退出本次循环</p><p>Goto 无条件转移语句</p><p>Return 无条件退出语句</p><h4 id="Set-语句"><a href="#Set-语句" class="headerlink" title="Set 语句"></a>Set 语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Declare  @zhang char(30)</span><br><span class="line"></span><br><span class="line">Set @zhang=&apos;zhangkaixu&apos;</span><br><span class="line"></span><br><span class="line">Select @zhang</span><br></pre></td></tr></table></figure><p>同时也可以使用select 语句进行赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare @zhang char(20), @li int </span><br><span class="line"></span><br><span class="line">select @zhang =&apos;zhangkaixu&apos;, @li =1233</span><br><span class="line"></span><br><span class="line">select @zhang ,@li</span><br></pre></td></tr></table></figure><p>可以同时赋值多个值。</p><h4 id="Begin-…-end-语句"><a href="#Begin-…-end-语句" class="headerlink" title="Begin … end 语句"></a>Begin … end 语句</h4><p>该语句可以将多个SQL语句组合成一个语句块。将语句块里面的作为一个单元处理，</p><p>例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line"></span><br><span class="line">select 姓名</span><br><span class="line"></span><br><span class="line"> from 学生</span><br><span class="line"></span><br><span class="line">where 专业=&apos;计类&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这个语句在后面的函数部分会用得到</p><h4 id="If-…-slse-语句"><a href="#If-…-slse-语句" class="headerlink" title="If … slse 语句"></a>If … slse 语句</h4><p>判定表达式是否成立，如果成立就执行下面的语句。如果不成立就执行else下的语句</p><p>也可以使用  else  if进行多重判定。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if exists(select * FROM 学生where 学生号=&apos;01003&apos;)</span><br><span class="line"> print &apos;存在学生号是01003的学生&apos;</span><br><span class="line"></span><br><span class="line">else if  (select avg (成绩) from 选课where 课程号=&apos;0003&apos;)&gt;60</span><br><span class="line"></span><br><span class="line"> print   &apos;平均成绩还好&apos;</span><br><span class="line"></span><br><span class="line">else </span><br><span class="line"></span><br><span class="line">print &apos;不存在或者平均成绩不好&apos;</span><br></pre></td></tr></table></figure><p>这里设定了如果学生表有01003的学生则打印第一条，否则如果课程号是0003的平均成绩大于60的话就打印第二条，如果都不是就打印第三条</p><h4 id="Case-语句"><a href="#Case-语句" class="headerlink" title="Case 语句"></a>Case 语句</h4><p>简单的case 语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Select 学生号,姓名,    --要注意的是CASE语句与其他的查询不同，这里最后一个列后面要加上逗号的。</span><br><span class="line"></span><br><span class="line">•    Case 专业</span><br><span class="line"></span><br><span class="line">•       When &apos;计算机&apos; then &apos;conputer &apos;</span><br><span class="line"></span><br><span class="line">•       When &apos;通信&apos; then &apos;tongxin&apos;</span><br><span class="line"></span><br><span class="line">•       When &apos;电子&apos; then &apos;dianzi&apos;</span><br><span class="line"></span><br><span class="line">End                       --这里必须加上end 表示结束</span><br><span class="line"></span><br><span class="line">From 学生</span><br></pre></td></tr></table></figure><p>注：</p><p>这里是在case 后列的when后面的几项如果存在就转化为then 后面的字符。就是查询了专业的拼音拼写。如果when后面没有给出列，就显示空。</p><h4 id="搜索型的case-语法"><a href="#搜索型的case-语法" class="headerlink" title="搜索型的case 语法"></a>搜索型的case 语法</h4><p>搜索型的相当于是新建了一个列，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Select 学生号,课程号,</span><br><span class="line"></span><br><span class="line">Case </span><br><span class="line"></span><br><span class="line">•    When 成绩&gt;=90 then &apos;a&apos;</span><br><span class="line"></span><br><span class="line">•    When 成绩&gt;=80 then  &apos;b&apos;</span><br><span class="line"></span><br><span class="line">•    When 成绩&gt;=70 then  &apos;c&apos;</span><br><span class="line"></span><br><span class="line">•    Else   &apos;o&apos;</span><br><span class="line"></span><br><span class="line">end as 评分</span><br><span class="line"></span><br><span class="line">from 选课</span><br></pre></td></tr></table></figure><p>这里将各个分数段的成绩赋予各个评分，并且将最后产生的列改名为‘评分’</p><p>注：</p><p>其实可以理解为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Case </span><br><span class="line"></span><br><span class="line">•    When 成绩&gt;=90 then &apos;a&apos;</span><br><span class="line"></span><br><span class="line">•    When 成绩&gt;=80 then  &apos;b&apos;</span><br><span class="line"></span><br><span class="line">•    When 成绩&gt;=70 then  &apos;c&apos;</span><br><span class="line"></span><br><span class="line">•    Else   &apos;o&apos;</span><br><span class="line"></span><br><span class="line">end as 评分</span><br></pre></td></tr></table></figure><p>上面的语句是第三个列，只是这个列不是固定的，会随着条件的变化而改变。</p><h4 id="Where-语句"><a href="#Where-语句" class="headerlink" title="Where 语句"></a>Where 语句</h4><p>Where 可以重复循环一个语句，</p><p>通过布尔表达式设定一个条件，当条件成立重复执行上一个语句或者语句块，可以使用break或者continue关键字结束全部循环或者本次循环</p><p>例：求1-100的累加和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">declare @i int,@j  int</span><br><span class="line"></span><br><span class="line">set @i=1</span><br><span class="line"></span><br><span class="line">set @j=0</span><br><span class="line"></span><br><span class="line">while   @i &lt;=100</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">•    set @j=@i + @j</span><br><span class="line"></span><br><span class="line">if @j&gt;=1000 break             --这里设置了当加到1000以上的时候就停止运算，如果不设置则加到@i=100</span><br><span class="line"></span><br><span class="line">•    set @i=@i + 1</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">select @i ,@j</span><br></pre></td></tr></table></figure><p>和c++类似，在这里begin……end  是设定一个语句块，如果不加以设定，那么就将一直指定第一条 set @j=@i + @j永无休止</p><h4 id="Goto-语句"><a href="#Goto-语句" class="headerlink" title="Goto 语句"></a>Goto 语句</h4><p>跳转到另一个标号后面的语句，可以相当于while 语句</p><p>例：</p><p>同样的求1-100的和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">declare @i int ,@j int </span><br><span class="line"></span><br><span class="line">select  @i=1,@j=0</span><br><span class="line"></span><br><span class="line">xunhuan:</span><br><span class="line"></span><br><span class="line">set @j=@i+@j</span><br><span class="line"></span><br><span class="line">set @i=@i+1</span><br><span class="line"></span><br><span class="line">if @i&lt;=100 goto xunhuan</span><br><span class="line"></span><br><span class="line">print @j</span><br></pre></td></tr></table></figure><h4 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h4><p>可以理解为只要出现了return 后面的所有都不会再执行，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">declare @i int ,@j int </span><br><span class="line"></span><br><span class="line">select  @i=1,@j=0</span><br><span class="line"></span><br><span class="line">xunhuan:</span><br><span class="line"></span><br><span class="line">set @j=@i+@j</span><br><span class="line"></span><br><span class="line">set @i=@i+1</span><br><span class="line"></span><br><span class="line">if @i&lt;=100 </span><br><span class="line"></span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">goto xunhuan</span><br><span class="line"></span><br><span class="line">print @j</span><br></pre></td></tr></table></figure><p>如上执行出来不会有结果。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>创建一个函数，写一个函数结构，在调用的时候只需调用函数的名称就可以，省事方便</p><h3 id="系统内置函数"><a href="#系统内置函数" class="headerlink" title="系统内置函数"></a>系统内置函数</h3><h4 id="确定性函数"><a href="#确定性函数" class="headerlink" title="确定性函数"></a>确定性函数</h4><p>就是说凡是输入特定的值调用这个函数其结果都是相同，确定值的。</p><h4 id="非确定性函数"><a href="#非确定性函数" class="headerlink" title="非确定性函数"></a>非确定性函数</h4><p>每次输入特定的值，调用函数都不相同，或者可能返回不同的结果。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select dateadd(m,10,&apos;1992-01-05&apos;)</span><br></pre></td></tr></table></figure><p>查询结果是</p><p>1992-11-05 00:00:00.000</p><p>每次都是这样的结果</p><p>select getdate()</p><p>查询结果</p><p>不定。</p><p>这就是确定函数和非确定函数的差别</p><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>常用的数学函数</p><p>1、 abs 求绝对值                –select abs(-9)  输出9</p><p>2、 cos 余弦函数                </p><p>3、 cot 余切函数</p><p>4、 exp 求计算e的X的次方        –select exp(3)   输出20.0855369231877</p><p>5、 floor 求仅次于最小值的整数值   </p><p>6、 log 求自然对数         –select log(5)  默认以e为底数1.6094379124341</p><p>7、 pi 常量，圆周率      –select pi()         3.14159265358979</p><p>8、 power 求x的y次方      –select power(2,3)  8</p><p>9、 rand 随机求数             </p><p>10、           round 四舍五入    –select round(1.54543134,3) 简化到小数点后3位</p><p>11、           sin 正弦函数</p><p>12、           square （求平方）            – select square(4)     输出16</p><p>13、           sqrt 求平方根           –select sqrt(4)      输出2</p><p>14、           tan 正切函数            –select tan(57.3)  输出近似1  1弧度≈57.3°</p><p>15、           convert 类型转换函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rand </span><br><span class="line"></span><br><span class="line">select floor (rand()*100)</span><br></pre></td></tr></table></figure><p>这里使用了两个数学函数，一个是取仅次于最小值的整数，还有就是将随机数乘以100，由于随机数是小于1的小数，所以这里将会输出1到100的随机整数。</p><p>这里所有的函数在进行调用的时候都需要在函数后面加上括号才可以。</p><p>注意的是tan（）函数所填写的是弧度的值，而不是角度的值</p><p>convert 类型转换函数</p><p>可以将字符的类型进行转换，</p><p>select convert (char(20),345)</p><p>还有要主意的单单的不加select 的函数是不可以执行的、</p><p>Cast 也是类型转换</p><p>Cast（表达式 as 新类型）</p><p>其他的不再解释。</p><p>有一个对SQL函数的详细说明网站，大家可以看看</p><p><a href="http://www.cnblogs.com/moss_tan_jun/archive/2010/08/23/1806861.html" target="_blank" rel="noopener">http://www.cnblogs.com/moss_tan_jun/archive/2010/08/23/1806861.html</a></p><h3 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h3><h4 id="Getdate-（）"><a href="#Getdate-（）" class="headerlink" title="Getdate （）"></a>Getdate （）</h4><p>返回系统当前时间的函数</p><p>Dateadd（日期的种类 ，时间间隔，一个时间） 用于求一个指定时间加上一个指定的数值，得到一个新的时间</p><p>日期的种类是指日或者年或者月之类的，</p><p>select dateadd (day,1,’2002-01-23’)</p><p>这里第三个参数时间格式的需要加上引号，第二个不需要加上引号，第一个参数是day或者month或者year。用于返回表达式中的日，月，年</p><h4 id="Datediff（）"><a href="#Datediff（）" class="headerlink" title="Datediff（）"></a>Datediff（）</h4><p>DATEADD()和DATEDIFF()函数可以看作一对表兄弟，有点像乘法与除法。在等式的两端有4个元素：起始日期、时间间隔(datepart)、差值和最终日期。如果已知其中的三个值，就可以求出第4个值。如果在DATEADD()函数中使用起始日期、一个整型值和一个时间间隔，就可返回与起始日期相关的最终日期值。如果提供了起始日期、时间间隔和最终日期，DATEDIFF()函数就可以返回差值。</p><p>为了说明这一点，我们选择任意两个日期与一个时间间隔作为参数。这个函数将以所提供的时间间隔为单位返回两个日期之间的差值。要知道1989年9月8日和1991年10月17日之间差了几个月，可编写如下查询代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATEDIFF(MONTH, &apos;9-8-1989&apos;, &apos;10-17-1991&apos;)</span><br></pre></td></tr></table></figure><p>结果是25个月。如果以日期为单位呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATEDIFF(DAY, &apos;9-8-1989&apos;, &apos;10-17-1991&apos;)</span><br></pre></td></tr></table></figure><p>结果是769天。</p><p>1996年7月2日和1997年8月4日之间差几个星期?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATEDIFF(WEEK, &apos;7-2-1996&apos;, &apos;8-4-1997&apos;)</span><br></pre></td></tr></table></figure><p>57星期。甚至可以算出自己的年龄是多少秒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @MyBirthDate   datetime    SET @MyBirthDate   = &apos;7-16-1962&apos;      SELECT DATEDIFF(SS, @MyBirthDate, GETDATE())</span><br></pre></td></tr></table></figure><p>结果显示有些人已经活了15亿秒了!</p><p>注：</p><p>这里的日期型的格式可以是月-日-年，也可以是年-月-日</p><h4 id="DATEPART-与DATENAME-函数"><a href="#DATEPART-与DATENAME-函数" class="headerlink" title="DATEPART()与DATENAME()函数"></a>DATEPART()与DATENAME()函数</h4><p>这两个函数用于返回datetime或者shortdatetime值的日期部分。DATEPART()函数返回一个整型值；DATENAME()函数返回一个包含描述性文字的字符串。比如，将日期4-29-1988传递给DATEPART()函数，如指定返回月份值，则返回数字4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATEPART(MONTH, &apos;4-29-1988&apos;)</span><br></pre></td></tr></table></figure><p>而使用相同的参数，DATENAME()函数返回04（这取决于你的机器的本地语言，如果是英文版，那么将返回April）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATENAME(MONTH, &apos;4-29-1988&apos;)</span><br></pre></td></tr></table></figure><p>这两个函数都接收和DATEADD()函数一样的时间间隔参数常量。</p><p>字符串函数</p><p>主要用来处理二进制类型的数据和字符串数据</p><p>Ascii 返回表达式最左边的字符的ASCII的值。</p><p>Char 返回整数所代表的ASCII值所对应的字符</p><p>Lower 将大写字符转换成小写字符</p><p>Upper 将小写字符转化成大写字符</p><p>Ltrim 删除字符段开始部分的空格</p><p>Rtrim 删除字符段尾部的空格</p><p>Right （字符串，数字）返回数字个数以后的字符串，当数字是负数的时候返回NULL</p><p>Space（数字） 返回由N个空格组成的字符串</p><p>Str（数值，长度，小数点的位置）  将数值型转化成字符串 </p><p>select str (6645,10,5)  输出6645.00000（一共是十个字符，小数点在左数第五个，）</p><p>Stuff （一个字符串，第几个字符，删除N个字符，将这个字符插入到删除掉的字符的位置）</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select stuff(&apos;zhang&apos;,3,2,&apos;kai&apos;)</span><br></pre></td></tr></table></figure><p>输出： zhkaig  注意必须填写四个参数，否则无法执行。</p><p>Substring （字符，第n个字符，返回N个字符）</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select substring(&apos;zhang&apos;,2,3)</span><br></pre></td></tr></table></figure><p>输出：han</p><p>Reveres （字符） 逆序返回字符串 </p><p>例“：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select reverse(&apos;zhang&apos;)</span><br></pre></td></tr></table></figure><p>输出 ：gnahz</p><p>Charindex （字符串，字符串2）返回字符串在字符串2的起始位置。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select charindex(&apos;k&apos;,&apos;zhangkaikxu&apos;)</span><br></pre></td></tr></table></figure><p>输出 6，返回在第一次出现这个位置的地方的第几个字符。</p><h3 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h3><p>可以分为标量函数和内嵌值表函数和多语句函数。</p><h4 id="标量函数"><a href="#标量函数" class="headerlink" title="标量函数"></a>标量函数</h4><p>返回类型是除了 text ntext image cursor timestamp 和table 类型以外的数据类型，函数体语句定义在gegin … end 之间，其中包含可以返回值的T-SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">create function f_(@kc char(7)) returns float</span><br><span class="line"></span><br><span class="line">as </span><br><span class="line"></span><br><span class="line">begin </span><br><span class="line"></span><br><span class="line">declare @avg float</span><br><span class="line"></span><br><span class="line">select @avg=(select avg(成绩) from 选课</span><br><span class="line"></span><br><span class="line">where 课程号= @kc )</span><br><span class="line"></span><br><span class="line">return @avg </span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">declare @zhang char(7)</span><br><span class="line"></span><br><span class="line">set @zhang =&apos;0002&apos;</span><br><span class="line"></span><br><span class="line">select dbo.f_(@zhang)              --这里必须添加函数所有者名dbo 当然也可以自己另定义，系统默认是dbo</span><br></pre></td></tr></table></figure><p>这样，一个简单的标量函数就出来了、</p><h4 id="内嵌值表函数"><a href="#内嵌值表函数" class="headerlink" title="内嵌值表函数"></a>内嵌值表函数</h4><p>以表的形式返回一个返回值，即返回的是一个表，没有用 begin…end 括起来的函数体，其返回的表是一个位于beturn 子句中 select 命令段 从数据库中筛选出来的，相当于是一个参数化的视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">alter function f_a (@zy varchar(20)=&apos;电商&apos;)  returns table</span><br><span class="line"></span><br><span class="line">as </span><br><span class="line"></span><br><span class="line">return </span><br><span class="line"></span><br><span class="line">(select 姓名,性别,年龄</span><br><span class="line"></span><br><span class="line">from 学生</span><br><span class="line"></span><br><span class="line">where 专业=@zy</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">declare @zhang varchar(20)</span><br><span class="line"></span><br><span class="line">set @zhang =&apos;计类&apos;</span><br><span class="line"></span><br><span class="line">select * from f_a(@zhang)</span><br></pre></td></tr></table></figure><p>这里与标量函数相同，都是相同的格式，只是返回了一个表的格式而已，然后就是在调用函数的时候，是select * form一个表、</p><h4 id="多语句函数"><a href="#多语句函数" class="headerlink" title="多语句函数"></a>多语句函数</h4><p>可以看作是标量型和内嵌表值型的结合体，返回值是表，但是同样是用begin …end 语句括起来的函数体。</p><p>优势是可以生成新的行。而不是单单的查询结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">create function [table] (@no char(7) ) returns @score table</span><br><span class="line"></span><br><span class="line">(学生号char(7),</span><br><span class="line"></span><br><span class="line">姓名char(6),</span><br><span class="line"></span><br><span class="line">课程名char(10),</span><br><span class="line"></span><br><span class="line">学分int ,</span><br><span class="line"></span><br><span class="line">成绩int </span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">as </span><br><span class="line"></span><br><span class="line">•    begin </span><br><span class="line"></span><br><span class="line">•       insert @score select 学生.学生号,学生.姓名,课程.课程名,课程.学分,选课.成绩</span><br><span class="line"></span><br><span class="line">from 学生,课程,选课</span><br><span class="line"></span><br><span class="line">where 学生.学生号=选课.学生号and 课程.课程号=选课.课程号and 学生.学生号=@no</span><br><span class="line"></span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">end </span><br><span class="line"></span><br><span class="line">declare @no char(7)</span><br><span class="line"></span><br><span class="line">set @no=&apos;010002&apos;</span><br><span class="line"></span><br><span class="line">select* from [table] (@no)</span><br></pre></td></tr></table></figure><p>注意的是这里调用函数的时侯也是使用select * from 函数名。（引用表的都要这样使用）Return要在begin …end之间。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>这里是主人的时间轴ヾ(〃^∇^)ﾉ</title>
      <link href="/2000/01/01/Timeline/"/>
      <url>/2000/01/01/Timeline/</url>
      
        <content type="html"><![CDATA[<h3 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a><code>2019年</code></h3><blockquote><p><code>02月</code> <code>论文</code> LIGHTWEIGHT NETWORK BASED ON INTERLEAVED GROUP CONVOLUTION FOR IMAGE SUPER-RESOLUTION[submitted]</p><blockquote><p>基于深度神经网络的图像超分辨率重建算法。</p></blockquote><p><code>02月</code> <code>论文</code> LOW-LIGHT IMAGE RESTORATION BASED ON DETAILS ENHANCER NETWORK[submitted]</p><blockquote><p>基于深度神经网络的低照度图像复原算法。</p></blockquote><p><code>01月</code> <code>软件著作权</code> 基于深度学习的图像智能识别系统</p><blockquote><p>基于keras，构建深度神经网络，结合饭否微博API，实现自动化机器人识图转发系统。</p><p>登记号：2019SR0022392</p><p>程序详情：<a href="https://zkeenly.github.io/2018/11/17/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E2%80%9C%E5%BE%AE%E5%8D%9A%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%9D%E8%AE%BE%E8%AE%A1/">图像智能识别程序设计</a> </p></blockquote></blockquote><h3 id="2018年"><a href="#2018年" class="headerlink" title="2018年"></a><code>2018年</code></h3><blockquote><p><code>07月-10月</code> <code>实习</code> 英然信息科技有限公司 </p><blockquote><p><code>python</code> <code>tensorflow</code><br>担任图像处理/计算机视觉 算法工程师。</p><ul><li>生猪数目统计：对于密集的生猪流动穿过通道，使用机器学习/光流追踪算法通过监控视频分析通过的生猪数量，准确度可达95%以上。项目难点：目标粘连，物体遮挡。</li><li>研究基于深度学习的物体分割，物体识别算法，Faster RCNN，SSD，Mask RCNN，人脸识别，3D点云图等。</li></ul></blockquote><p><code>05月</code> <code>项目</code> <a href="https://zkeenly.github.io/2018/11/17/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E2%80%9C%E5%BE%AE%E5%8D%9A%E4%BA%BA%E5%83%8F%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%99%A8%E4%BA%BA%E2%80%9D%E8%AE%BE%E8%AE%A1/">图像智能识别程序设计</a> </p><blockquote><p><code>keras</code> <code>python</code> <code>tensorflow</code><br>通过keras，构建VGG16神经网络，结合饭否微博API，实现自动化机器人识图转发系统。截止到2018年11月，已有200+用户关注，并申请软件著作权。</p></blockquote><p><code>03月</code> <code>研究</code> 超分辨率算法研究</p><blockquote><p><code>caffe</code> <code>超分辨率重建</code> <code>深度学习</code> <code>机器学习</code><br>研究学习基于深度学习的单帧/多帧超分辨率重建算法。<br>系统学习机器学习理论知识。<br>研究VDSR,RESNET,DRRN,Dense Net,等神经网络的研究以及实现。</p></blockquote></blockquote><h3 id="2017年"><a href="#2017年" class="headerlink" title="2017年"></a><code>2017年</code></h3><blockquote><p><code>12月</code> <code>证书</code> 获得 全国大学生英语四级 证书</p><p><code>09月</code> <code>入学</code> 通过全国研究生入学考试，就读于“<a href="http://www.ccnu.edu.cn/" target="_blank" rel="noopener">华中师范大学</a>-<a href="http://cs.ccnu.edu.cn/" target="_blank" rel="noopener">计算机技术</a>”</p><blockquote><p>导师：<a href="http://cs.ccnu.edu.cn/info/1048/1270.htm" target="_blank" rel="noopener">谢伟</a>。<br>研究方向：数字图像处理/计算机视觉/机器学习/深度学习。</p></blockquote><p><code>6月-9月</code> <code>实习</code> 武汉富士康集团有限公司</p><blockquote><p>软件测试/系统测试</p></blockquote></blockquote><h3 id="2016年"><a href="#2016年" class="headerlink" title="2016年"></a><code>2016年</code></h3><blockquote><p><code>12月</code> <code>证书</code> 获得全国英语等级考试 第三级 口语证书 &amp; 全国计算机等级考试 第二级 C语言证书</p><p><code>09月</code> <code>互联网</code> 哔哩哔哩-首批知名学播UP主之一 <a href="https://live.bilibili.com/374141" target="_blank" rel="noopener">K君的自习室</a> </p><p><code>06月</code> <code>毕业论文</code> 《邢台地区特色商品购物网站设计》</p><blockquote><p><code>ASP.NET</code><br>通过ASP.NET实现完整的购物网站设计，具备前台/后台/购物车/支付等完整的功能实现。</p></blockquote><p><code>03月-05月</code> <code>实习</code> 邢台市卫生局</p><blockquote><p>维护邢台市卫生局单位网络/计算设备等正常工作。</p></blockquote></blockquote><h3 id="2015年"><a href="#2015年" class="headerlink" title="2015年"></a><code>2015年</code></h3><blockquote><p><code>09月</code> <code>项目</code> 下载链接爬虫网站</p><blockquote><p><code>JSP</code> <code>HTML</code> <code>java</code><br>校园网改造，提供缓存文件急速下载服务（仅提供日下载量top10的下载连接）。</p><ul><li>为解决下载链接数量限制，与舍友xqzhang共同设计-下载链接爬虫网站：抓取校园网缓存文件链接。提供校友便捷高速下载大文件（运营数日访问量即达到数千）。</li></ul></blockquote><p><code>06月</code> <code>实习</code> 河北恒研电子有限公司</p><blockquote><ul><li>监控设备安装，大型监控网络布局，服务器/路由器设备调试。海康/大华等摄像头设备的配置与安装。</li></ul></blockquote><p><code>03月</code> <code>项目</code> google-hosts 修改神器</p><blockquote><p><code>C#.NET</code><br>2015年，大陆google域名完全被ban，但是部分IP仍可直接访问google。</p><ul><li>使用C#.NET制作<a href="https://github.com/zkeenly/google-hosts" target="_blank" rel="noopener">google-hosts修改神器</a>：可一键修改windows系统本机hosts文件，以直接访问Google。<br>曾获得数千下载量。</li></ul></blockquote></blockquote><h3 id="2014年"><a href="#2014年" class="headerlink" title="2014年"></a><code>2014年</code></h3><blockquote><p><code>09月</code> <code>入学</code> 通过河北省专升本考试，就读于“<a href="http://www.xttc.edu.cn/" target="_blank" rel="noopener">邢台学院</a>-<a href="http://xkx.xttc.edu.cn/" target="_blank" rel="noopener">计算机科学与技术</a>”</p><p><code>03月</code> <code>证书</code> 获得 机动车驾驶证（C1）</p></blockquote><h3 id="2013年"><a href="#2013年" class="headerlink" title="2013年"></a><code>2013年</code></h3><blockquote><p><code>09月</code>  <code>项目</code> 承接“保定学院-宣传部网站”的制作 <a href="https://github.com/zkeenly/newsweb" target="_blank" rel="noopener">保定学院-宣传部网站</a></p><blockquote><p><code>ASP.NET</code> <code>HTML</code> <code>DW</code><br>该网站采用ASP.NET设计，分为前台后台两部分，可以通过后台登陆，发布/管理新闻。</p></blockquote></blockquote><h3 id="2012年"><a href="#2012年" class="headerlink" title="2012年"></a><code>2012年</code></h3><blockquote><p><code>2012年09月</code>-<code>2014年06月</code> <code>兼职</code> 担任保定学院校园网管理员</p><blockquote><p><code>运维</code> <code>服务器</code><br>处理SQL,DNS,WEB,FTP,Linux/Win服务器异常事件<br>维护校园网络正常运作/配置交换机路由器<br>选课系统维护/防护校园网站被入侵</p></blockquote></blockquote><h3 id="2011年"><a href="#2011年" class="headerlink" title="2011年"></a><code>2011年</code></h3><blockquote><p><code>09月</code> <code>01日</code> <code>入学</code> 通过高考，就读于“<a href="http://www.bdu.edu.cn/default.html" target="_blank" rel="noopener">保定学院</a>-<a href="http://221.192.237.22:8056/sxx/default.html" target="_blank" rel="noopener">计算机类</a>”</p></blockquote><h3 id="1993年"><a href="#1993年" class="headerlink" title="1993年"></a><code>1993年</code></h3><blockquote><p><code>1993年</code> <code>12月</code> <code>03日</code> 出生于“河北省邯郸市”</p></blockquote>]]></content>
      
      
      
    </entry>
    
  
  
</search>
